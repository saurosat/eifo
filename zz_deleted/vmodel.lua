---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tnguyen.
--- DateTime: 12/10/23 10:29 AM
---

---
--- view model
--- similar to VIEW in SQL
--- Keep a left join vmodel and right join vmodel, each one can have other vmodels joined
---     1. each leftVModel should keep a ref to self in __index to prevent infinite loop
---     2. each rightVModel is similar
---     3. Many-To-One FK field to be replaced by a ref to a record in leftVModel
---     4. One-To-Many field to be replaced by a list of records in rightTables
---     5. Currently support only 3 methods of loading records: i. loadOne (using key),
--- ii. loadAll and iii. loadByFK: load by a Many-To-Ond FK value, such as load all products
--- of a category. The next step is to support query and full text search
---     6. there are two options for the mechanism to update view:
---         i. Each view maintain 1 JSON file to store data about entities that related to
---              rendered files. When rendering, append to that file. When updating, load all file
---              then delete all, then put back unchanged file info and append rerendered file info
---         ii. The topic includes 3 info: ED name, Field name and key.
---         Because views are stored in memory, scan through all view and check if its model is related
---         to the topic ED name and column. If yes, calculate the outPathFile and delete if it exists
---         For each view, get main model:
---             + If topic ED name is the main ED: check key
---             + If topic ED name is belong to Left: create model of topicED, then
---              loadRights for main ED name then delete all files of found keys
---             + If topic ED name belong to Right, create model of topic ED then join left to find
---             out the affected key
---         Because each view can only attach with 1 main entity, we can find the direct views affected
---         Then we can create a full model (with all possible left and right joins) to find other
---          affected views
---         NOTE: with this solution, the main ed of model should have only one record, otherwise,
---         there is no way to calculate outFileName
---         For the case of index page, we have to make a 'index' virtual ED in dao.lua, and create FK
---         in other EDs (Category) to it
---
require "eifo.vrecord"
local ED = eifo.db.ed
local utils = eifo.utils
local eval = loadstring
local setmetatable = setmetatable
local ngx = ngx
local VModelBuilder = utils.newHashTbl(3)
VModelBuilder.registry = {}
local function newVRecord(selfInstance, evValues)
    local vrClass = eifo.vrecord[selfInstance.ed.ename]
    if not vrClass then
        vrClass = eifo.vrecord
    end
    return vrClass:newInstance(selfInstance, evValues or {})
end

--- Look for vModel that having given main Entity Definition
--- return the found vmodel and paths to it from original entity 
local function lookup(self, paths, ev)
    local resultPaths = paths or {}
    local selfEName = self.ed.ename
    ngx.log(ngx.DEBUG, "START Entity: "..selfEName..". "..table.concat(resultPaths, ", "))
    local eName = ev.ed.ename
    if selfEName == eName then
        local cols = self.columns
        local numCols = #cols
        if numCols == 0 then
            return self
        end
        for i = 1, numCols do
            if ev[cols[i]] then
                return self
            end
        end
        return nil, resultPaths
    end
    -- Check lefts and rights before recursion for better performance
    if self.leftTables[eName] then
        resultPaths[#resultPaths + 1] = eName -- Odd index for left
        resultPaths[#resultPaths + 1] = "" -- Even index for right. Use empty string instead of nil to make the array expand
        return self.leftTables[eName]:lookup(resultPaths, ev)
    end
    if self.rightTables[eName] then
        resultPaths[#resultPaths + 1] = "" -- Odd index for left. Use empty string instead of nil to make the array expand
        resultPaths[#resultPaths + 1] = eName -- Even index for right.
        return self.rightTables[eName]:lookup(resultPaths, ev)
    end
    ngx.log(ngx.DEBUG, selfEName.."'s Left entities:")
    local vModels = self.leftTables
    for k, v in pairs(vModels) do
        --if k ~= resultPaths[#resultPaths] then --> check last path from Right to avoid infinite loop
            -- Add path to this node (Assume that result will be found here)
            resultPaths[#resultPaths + 1] = k  -- Odd index for left.
            resultPaths[#resultPaths + 1] = ""
            local vModel, paths = v:lookup(resultPaths, ev)
            if vModel then
                return vModel, paths
            end
            -- Not found. revert the path back (Delete two array items that have been added above)
            resultPaths[#resultPaths] = nil
            resultPaths[#resultPaths] = nil
        --end
    end
    ngx.log(ngx.DEBUG, "END "..selfEName.."'s Left entities.")
    ngx.log(ngx.DEBUG, selfEName.."'s Right entities: ")
    vModels = self.rightTables
    for k, v in pairs(vModels) do
        --if k ~= resultPaths[#resultPaths - 1] then --> check last path from Left to avoid infinite loop
            -- Add path to this node (Assume that result will be found here)
            resultPaths[#resultPaths + 1] = ""
            resultPaths[#resultPaths + 1] = k  -- Even index for right.
            local vModel, paths = v:lookup(resultPaths, ev)
            if vModel then
                return vModel, paths
            end
            -- Not found. revert the path back (Delete two array items that have been added above)
            resultPaths[#resultPaths] = nil
            resultPaths[#resultPaths] = nil
        --end
    end
    ngx.log(ngx.DEBUG, "END "..selfEName.."'s Right entities. ")
    ngx.log(ngx.DEBUG, "END Entity: "..selfEName.."___________________________________")
    -- Not found any where in this node
    return nil, resultPaths
end
---
--- The paths params will be visit from tail
local function traverseBack(self, paths)
    if #paths == 0 then
        return self
    end
    local vModel = nil
    local eName = paths[#paths]
    paths[#paths] = nil -- remove last item
    -- traversing backward hence even is LEFT, odd is RIGHT
    if eName == "" then -- even is empty.
        eName = paths[#paths] -- odd. even is empty ==> odd must not empty.
        vModel = self.rightTables[eName] -- odd is RIGHT
    else -- even not empty
        vModel = self.leftTables[eName] -- even is LEFT
    end
    paths[#paths] = nil -- remove second-last item
    assert(vModel ~= nil)
    return vModel:traverseBack(paths)
end
local function notifyAll(self, topic)
    if self.notified then
        return
    end
    self:_notify(topic)
    for _, v in pairs(self.leftTables) do
        v:notifyAll(topic)
    end
    if self.parent then
        self.parent:notifyAll(topic)
    end
    self.notified = true
end
local function addRecordCommon(self, key, value)
    self.recordCommons[key] = value
end
local function addColumns(self, ...)
    local columns = {...}
    local numCols = #columns
    if numCols == 0 then
        return self
    end

    local selfColumns = self.columns
    local numSelfCols = #selfColumns
    local col
    for i = 1, numCols, 1 do
        col = columns[i]
        for j = 1, numSelfCols, 1 do
            if col == selfColumns[j] then
                col = nil
                break
            end
        end
        if col then
            numSelfCols = numSelfCols + 1
            selfColumns[numSelfCols] = col
        end
    end
    return self
end
local function addFilter(self, condition, fKeyColumn)
    local sFunction = "local f = function(entity) return "..condition.." end return f"
    local fCondition = assert(eval(sFunction))()
    -- ngx.log(ngx.DEBUG, utils.toString(fCondition))
    local filters = (fKeyColumn and self.leftCols[fKeyColumn]) or self.filters
    filters[#filters + 1] = function(ev)
        return fCondition(ev)
    end
    return self
end

local function getRecord(selfInstance, key, conn)
    if not key then
        return nil
    end
    local record = selfInstance.keys[key]
    if not record and conn then
        return selfInstance:loadByKey(key, conn)
    end
    return record
end
local function loadByIds(selfInstance, ids, conn, reversed, colValues)
    if selfInstance._level >= selfInstance.maxLevel then
        return nil    
    end
    selfInstance._level = selfInstance._level + 1
    local eName = selfInstance.ed.ename
    local ev = selfInstance.ed[eName]:new(ids)
    local evValues = ev:load(conn)
    if not evValues then
        local err = "Entity IDs ("..table.concat(ids, ", ")..") not found in "..eName
        ngx.log(ngx.INFO, err)
        selfInstance._level = selfInstance._level - 1
        return nil, err
    end
    local vRecord = selfInstance:addRecord(ev, conn, reversed)
    selfInstance._level = selfInstance._level - 1
    if selfInstance.onLoaded and selfInstance._level == 0 and not reversed then
        selfInstance:onLoaded(vRecord)
    end
    return vRecord
end
local function loadByKey(selfInstance, key, conn, reversed)
    local vRecord = selfInstance.keys[key]
    if vRecord then
        return vRecord
    end
    ngx.log(ngx.DEBUG, selfInstance.ed.ename.."loadByKey '"..key.."', level="..selfInstance._level
             ..", maxLevel="..selfInstance.maxLevel)

    if selfInstance._level >= selfInstance.maxLevel then
        return nil
    end
    selfInstance._level = selfInstance._level + 1
    local ev = selfInstance.ed:get(key, conn)
    if not ev then
        local err = "Entity key '"..key.."' not found in "..selfInstance.ed.ename
        ngx.log(ngx.INFO, err)
        selfInstance._level = selfInstance._level - 1
        return nil, err
    end
    local nowEpoch = os.time()
    if selfInstance.removeExpired and ev.values.thruDate then
        local thruEpoch = utils.timeFromDbStr(ev.values.thruDate)
        if thruEpoch < nowEpoch then
            ev:delete(conn)
            ev = nil
        end 
    end
    if not ev then
        return nil
    end
    vRecord = selfInstance:addRecord(ev, conn, reversed)
    selfInstance._level = selfInstance._level - 1
    if selfInstance.onLoaded and selfInstance._level == 0 and not reversed then
        selfInstance:onLoaded(vRecord)
    end
    return vRecord
end
local function filterPassed(record, filters)
    for i = 1, #filters, 1 do
        local status, pass = pcall(filters[i], record)
        -- ngx.log(ngx.DEBUG, utils.toString(filters[i])..
        --     "\r Record: "..utils.toString(record)..
        --     ".\r Result: status = "..(status and "OK" or "Error")..". Returned = "..(pass and "Pass" or "Failed"))
        if not status then
            ngx.log(ngx.ERR, "Filter "..utils.toString(filters[i]).." can not be evaluated")
            return false
        end
        if not pass then
            return false
        end
    end
    return true
end
local function addRecordWithoutRels(selfInstance, ev, disableFilter)
        -- unchecked: ev should be of type selfInstance.ed
    -- Apply filters
    if not disableFilter and not filterPassed(ev.values, selfInstance.filters) then
        -- ngx.log(ngx.DEBUG, ev.values.key..": filtered out")
        return nil
    end

    -- process Entity Values
    local values = ev.values
    local cols = selfInstance.columns
    local numCols = (cols and #cols) or 0
    local vRecord = newVRecord(selfInstance)
    if numCols > 0 then
        for i = 1, numCols, 1 do
            vRecord[cols[i]] = values[cols[i]]
        end
        vRecord["key"] = values["key"]
        local ids = ev.ed.fnIds
        for i = 1, #ids, 1 do
            vRecord[ids[i]] = values[ids[i]]
        end
    else
        for k, v in pairs(values) do
            vRecord[k] = v
        end
    end
    selfInstance[#selfInstance + 1] = vRecord
    selfInstance.keys[vRecord.key] = vRecord
    return vRecord
end
local function loadLeft(selfInstance, vRecord, conn, reversed)
    if vRecord == nil then
        return
    end
    local leftCols = selfInstance.leftCols
    for k, v in pairs(leftCols) do
        local vModel = selfInstance.leftTables[v.eName]
        if vModel then
            local leftKey = vRecord[k]
            if conn and not vModel:getRecord(leftKey) then -- load left record when needed:
                vModel:loadByKey(leftKey, conn, reversed)
            end
    
            if not selfInstance.groupBy[k][leftKey] then
                selfInstance.groupBy[k][leftKey] = utils.ArraySet:new()
            end
            selfInstance.groupBy[k][leftKey]:add(vRecord)
        end
    end
end
local function loadRight(selfInstance, vRecord, conn)
    if vRecord == nil then
        return
    end
    local rightCols = selfInstance.rightCols
    for k, v in pairs(rightCols) do
        --ngx.log(ngx.DEBUG, selfInstance.ed.ename.." right join to "..v[1]..", column "..v[2])
        local vModel = selfInstance.rightTables[v[1]] --> v[1] is table name
        if vModel then
            vModel:loadByFk(v[2], vRecord.key, conn)
        end
    end
end
local function loadReversed(selfInstance, vRecord, conn) 
    loadLeft(selfInstance, vRecord, conn, true)
    local parent = selfInstance.parent
    if not parent then --> self is the main vmodel
        return vRecord
    end
    local fkCol = selfInstance.toParentCol
    if not fkCol  then
        local errMsg = "FK column linked to parent vModel is not set"
        ngx.log(ngx.ERR, errMsg)
        -- logically, in case of error, the result should not be added
        selfInstance[#selfInstance] = nil
        selfInstance.keys[vRecord.key] = nil
        return nil, errMsg
    end
    local posInParent = selfInstance.posInParent
    if not fkCol or not posInParent then
        local errMsg = "Parent position is not set"
        ngx.log(ngx.ERR, errMsg)
        -- logically, in case of error, the result should not be added
        selfInstance[#selfInstance] = nil
        selfInstance.keys[vRecord.key] = nil
        return nil, errMsg
    end
    if posInParent == 1 then -- only load rights because all lefts have been loaded 
        local rightInfo = selfInstance.rightCols[fkCol]
        if not rightInfo then
            local errMsg = "Alias column linked to parent vModel is not set"
            ngx.log(ngx.ERR, errMsg)
            -- logically, in case of error, the result should not be added
            selfInstance[#selfInstance] = nil
            selfInstance.keys[vRecord.key] = nil
            return nil, errMsg
        end
        parent:loadByFk(rightInfo[2], vRecord.key, conn, true)
    end
end

-- unchecked: ev should be of type selfInstance.ed
local function addRecord(selfInstance, ev, conn, reversed, disableFilter)
    -- process Entity Values
    local vRecord = addRecordWithoutRels(selfInstance, ev, disableFilter)
    if not vRecord then
        return nil
    end
    if reversed then
        loadReversed(selfInstance, vRecord, conn)
    else
        -- process left joined columns:
        loadLeft(selfInstance, vRecord, conn)
        -- process right joined columns:
        loadRight(selfInstance, vRecord, conn)
        if vRecord.onLoaded then
            vRecord:onLoaded()
        end
    end

    return vRecord
end
local function loadByFk(selfInstance, fKeyColumn, fKeyValue, conn, reversed)
    ngx.log(ngx.DEBUG, "loadByFk "..fKeyColumn.."= "..fKeyValue)
    local joinInfo = selfInstance.leftCols[fKeyColumn]
    if not joinInfo then
        local err = "Join relation is not declared: ".. fKeyColumn
        ngx.log(ngx.ERR, err)
        return nil, err
    end
    local group = selfInstance.groupBy[fKeyColumn][fKeyValue]
    if not group then
        group = utils.ArraySet:new() -- records will be added to group in 'addRecord'
        selfInstance.groupBy[fKeyColumn][fKeyValue] = group
    end
    if joinInfo.loadedBy and joinInfo.loadedBy[fKeyValue] then
        ngx.log(ngx.DEBUG, "joinInfo.loadedBy[fKeyValue] = "..joinInfo.loadedBy[fKeyValue])
        return group
    end

    if selfInstance._level >= selfInstance.maxLevel then
        ngx.log(ngx.DEBUG, "selfInstance._level = "..selfInstance._level)
        return nil
    end
    selfInstance._level = selfInstance._level + 1
    local filters = joinInfo
    local ev = ED[joinInfo.eName]:new({key = fKeyValue}, true)
    local keys = ev:getChildrenIds(selfInstance.ed.ename, fKeyColumn, conn) or {}

    local records = utils.newArray(#keys);
    local nowEpoch = os.time()

    for i = 1, #keys, 1 do
        local record = selfInstance:getRecord(keys[i])
        if not record then
            local ev
            if selfInstance.idOnly then
                ev = {values = {}}
                ev.values.key = keys[i]
                ev.values[fKeyColumn] = fKeyValue
            else
                ev = selfInstance.ed:get(keys[i], conn)
                if ev and ev.values.thruDate and selfInstance.removeExpired then
                    local thruEpoch = utils.timeFromDbStr(ev.values.thruDate)
                    if thruEpoch < nowEpoch then
                        ev:delete(conn)
                        ev = nil
                    end 
                end
            end
            if ev then
                record = addRecordWithoutRels(selfInstance, ev)
                if record then
                    records[#records+1] = record
                end
            end
        end
    end
    if reversed then
        for i = 1, #records, 1 do
            loadReversed(selfInstance, records[i], conn)
        end
    else
        for i = 1, #records, 1 do
            -- process left joined columns:
            loadLeft(selfInstance, records[i], conn)
            -- process right joined columns:
            loadRight(selfInstance, records[i], conn)
            if records[i].onLoaded then
                records[i]:onLoaded()
            end
        end
        selfInstance._level = selfInstance._level - 1
        if selfInstance.onLoaded and selfInstance._level == 0 and not reversed then
            selfInstance:onLoaded(table.unpack(group))
        end
    end
    if not joinInfo.loadedBy then
        joinInfo.loadedBy = {}
    end
    joinInfo.loadedBy[fKeyValue] = true
    return group
end

function select(selfInstance, where)
    local sFunction = "local f = function(entity) return "..where.." end return f"
    local fWhere = assert(eval(sFunction))()
    local numRecords = #selfInstance
    local records = utils.newTable(numRecords, 0)
    for i = 1, numRecords, 1 do
        local status, pass = pcall(fWhere, selfInstance[i])
        if not status then
            ngx.log(ngx.ERR, "Filter "..utils.toString(fWhere).." can not be evaluated")
            return false
        end
        if pass then
            records[#records+1] = selfInstance[i]
        --     if not selfInstance[i].parents then
        --         ngx.log(ngx.DEBUG, "Record "..selfInstance[i].key.." has no parents")
        --     else
        --         ngx.log(ngx.DEBUG, "Record "..selfInstance[i].key.." has "..(#selfInstance[i].parents).." parents")
        --     end
        -- else
        --     ngx.log(ngx.DEBUG, "Record "..selfInstance[i].key.." is filtered out")
        end
    end
    return records
end


local __instance = utils.ArraySet:new()
__instance.lookup = lookup
__instance.traverseBack = traverseBack
__instance.notifyAll = notifyAll
__instance.getRecord = getRecord
__instance.addRecord = addRecord
__instance.loadByKey = loadByKey
__instance.loadByIds = loadByIds
__instance.loadByFk = loadByFk
__instance.select = select
__instance._notify = utils.observable._notify
__instance.addRecordCommon = addRecordCommon
__instance.addColumns = addColumns
__instance.addFilter = addFilter

local function addVModel(self, vModel, pos)
    local modelEName = vModel.ed.ename
    if pos > 0 then
        self.leftTables[modelEName] = vModel
    else
        self.rightTables[modelEName] = vModel
    end
    vModel.parent = self
    vModel.posInParent = pos
    ngx.log(ngx.DEBUG, self.ed.ename.." is parent of "..modelEName)
    return vModel
end
local function leftJoin(selfClass, fKeyColumn, aliasForFkObj, onCondition,...)
    local selfEName = selfClass.ed.ename
    local edFKs = selfClass.ed.fnFKs;
    local fkEName = edFKs[fKeyColumn]
    if not fkEName then
        local errMsg = "Entity '"..selfEName.."' does not have FK column "..fKeyColumn
        ngx.log(ngx.ERR, errMsg)
        return nil, errMsg
    end
    if selfClass.leftCols[fKeyColumn] then
        return selfClass.leftTables[fkEName]
    end

    -- ngx.log(ngx.DEBUG, "Adding Left join "..selfEName.." TO "..fkEName)

    local vModel, err = selfClass.leftTables[fkEName], nil
    if not vModel then
        vModel, err = VModelBuilder.new(nil, fkEName)
        if vModel then
            vModel.toParentCol = aliasForFkObj
            addVModel(selfClass, vModel, 1)
        end
    end
    if not vModel then
        ngx.log(ngx.ERR, err)
        return nil, err
    end

    vModel:addColumns(...)
    vModel.rightCols[aliasForFkObj] = {selfClass.ed.ename, fKeyColumn}
    selfClass.leftCols[fKeyColumn] = {eName = vModel.ed.ename}
    return vModel
end
local function rightJoin(selfClass, eName, fKeyColumn, alias, onCondition,...)
    if selfClass.rightCols[alias] then
        return selfClass.rightTables[eName]
    end
    local ed = ED[eName]
    if not ed then
        local errMsg = "Entity name '".. eName .."' not found "
        ngx.log(ngx.ERR, errMsg)
        return nil, errMsg
    end
    local selfEName = ed.fnFKs[fKeyColumn]
    if not selfEName or selfEName ~= selfClass.ed.ename then
        local errMsg = "Entity name '"..eName.."' does not have FK relationship to "..selfClass.ed.ename
        ngx.log(ngx.ERR, errMsg)
        return nil, errMsg
    end

    local vModel, err = selfClass.rightTables[eName], nil
    if vModel and vModel.leftCols[fKeyColumn] then
        return vModel
    end

    -- ngx.log(ngx.DEBUG, "Adding Right join "..selfClass.ed.ename.." TO "..eName)
    if not vModel then
        vModel, err = VModelBuilder.new(nil, eName)
        if vModel then
            vModel.toParentCol = fKeyColumn
            addVModel(selfClass, vModel, -1)
        end
    end
    if not vModel then
        ngx.log(ngx.ERR, err)
        return nil, err
    end
    vModel:addColumns(...)
    vModel.leftCols[fKeyColumn] = {eName = selfClass.ed.ename}
    if onCondition then
        vModel:addFilter(onCondition, fKeyColumn)
    end
    selfClass.rightCols[alias] = {eName, fKeyColumn}
    return vModel
end

local function _update(selfClass, ev, oldVals)
    -- ngx.log(ngx.DEBUG, "VModelBuilder '"..selfClass.name.."' UPDATING: \r\n"
    --         ..utils.toString(ev, ": ", "\r\n"))
    if not ev.values.key then
        local ok, err = ev:resetKey()
        if not ok then
            return ok, err
        end
    end
    local vModel = selfClass:newVModel(true)
    local conn, err = eifo.db.conn.redis()
    if not conn then
        return nil, err
    end
    conn:connect()
    --local vRecord, err = vModel:loadByKey(ev.values.key, conn, true)
    local vRecord, ERR = vModel:addRecord(ev, conn, true)
    conn:disconnect()
    if not vRecord then
        local errMsg = "Can not find entity while updating for key '"
            ..ev.values.key.."'. Please check maxLevel setting"..(err or "")
        ngx.log(ngx.CRIT, errMsg)
        return nil, errMsg
    end
    vModel:notifyAll(oldVals)
    return vModel
end

local function newVModel(selfClass, ignoredTables)
    if selfClass.parent then
        local parent = selfClass.parent:newVModel()
        if selfClass.posInParent == 1 then
            return parent.leftTables[selfClass.ed.ename]
        else
            return parent.rightTables[selfClass.ed.ename]
        end
    end
    local instance = setmetatable(utils.newTable(50, 11), {
        __index = __instance
    })
    instance._observers = selfClass._observers --> this will be created in selfClass when first observer attach
    -- if instance._observers then
    --     for id, observer in pairs(instance._observers) do
    --         ngx.log(ngx.DEBUG, "instance's observer '"..id.."': "..utils.toString(observer, ": ", "\r\n"))
    --     end
    -- end

    instance.ed = selfClass.ed
    -- if instance.ed._observers then
    --     for id, observer in pairs(instance.ed._observers) do
    --         ngx.log(ngx.DEBUG, "ED's observer '"..id.."': "..utils.toString(observer, ": ", "\r\n"))
    --     end
    -- end
    instance.maxLevel = selfClass.maxLevel
    instance._level = 0
    instance.columns = utils.clone(selfClass.columns)
    instance.filters = utils.clone(selfClass.filters)
    instance.toParentCol = selfClass.toParentCol
    instance.onLoaded = selfClass.onLoaded
    instance.recordCommons = utils.clone(selfClass.recordCommons)
    instance.removeExpired = selfClass.removeExpired


    instance.keys = {}
    instance.groupBy = {}
    for k, _ in pairs(selfClass.leftCols) do
        instance.groupBy[k] = {}
    end

    instance.leftTables = setmetatable({}, {
        __index = function(_, key)
            -- ngx.log(ngx.DEBUG, "Left table metamethod invoked with instance.parent is "..(instance.parent and "not null" or "nil"))
            if instance.parent and instance.posInParent == -1 -- right
                    and key == instance.parent.ed.ename then
                        return instance.parent
            end
            return nil
        end
    })
    instance.leftCols = {}
    -- ngx.log(ngx.DEBUG, "Copying Left tables of "..instance.ed.ename)
    for k, v in pairs(selfClass.leftTables) do
        if (not ignoredTables) or string.find(ignoredTables, k) == nil then
            -- ngx.log(ngx.DEBUG, "+ k = "..k..", v = "..(v.ed and v.ed.ename or "No ED"))
            local vModel = v:newVModel()
            instance.leftCols[k] = utils.clone(selfClass.leftCols[k])
            instance.leftTables[k] = vModel
            vModel.parent = instance
            vModel.posInParent = 1
        end
    end

    instance.rightTables = setmetatable({}, {
        __index = function(_, key)
            -- ngx.log(ngx.DEBUG, "Right table metamethod invoked instance.parent is "..(instance.parent and "not null" or "nil"))
            if instance.parent and instance.posInParent == 1 -- left
                    and key == instance.parent.ed.ename then
                return instance.parent
            end
            return nil
        end
    })
    instance.rightCols = {}
    -- ngx.log(ngx.DEBUG, "Copying Right tables of "..instance.ed.ename)
    for k, v in pairs(selfClass.rightTables) do
        -- ngx.log(ngx.DEBUG, "+ k = "..k..", v = "..(v.ed and v.ed.ename or "No ED"))
        local vModel = v:newVModel()
        selfClass.rightCols[k] = utils.clone(selfClass.rightCols[k])
        vModel.parent = instance
        vModel.posInParent = -1
        instance.rightTables[k] = vModel
    end
    -- for k, v in pairs(instance.leftTables) do
    --     ngx.log(ngx.DEBUG, "Instance Left tables "..instance.ed.ename..": k = "..k..", v = "..v.ed.ename)
    -- end
    -- for k, v in pairs(instance.rightTables) do
    --     ngx.log(ngx.DEBUG, "Instance Right tables: "..instance.ed.ename.." k = "..k..", v = "..v.ed.ename)
    -- end

    -- ngx.log(ngx.DEBUG, "Done "..instance.ed.ename)
    return instance
end
local __vMClass = utils.newTable(0, 10)
__vMClass.addRecordCommon = addRecordCommon
__vMClass.addColumns = addColumns
__vMClass.addFilter = addFilter
__vMClass.leftJoin = leftJoin
__vMClass.rightJoin = rightJoin
__vMClass.lookup = lookup
__vMClass.newVModel = newVModel
__vMClass._attach = utils.observable._attach
__vMClass._detach = utils.observable._detach
__vMClass._update = _update

VModelBuilder.new = function(name, eName, ...)
    local ed = ED[eName]
    if not ed then
        return nil, "Unknown entity name "..eName
    end
    local registry = VModelBuilder.registry
    if not name then
        name = eName
        local i = 1
        while registry[name] do
            name = eName.."#"..i
            i = i + 1
        end
    end
    local builder = {
        name = name,
        _observerId = name,
        maxLevel = 100,
        ed = ed,
        columns = {...},
        leftCols = {},
        rightCols = {},
        filters = {},
        recordCommons = {}
    }
    setmetatable(builder, { __index = __vMClass })
    builder.leftTables = setmetatable({}, {__index =
        function(_, key)
            if builder.parent and builder.posInParent == -1  --right
                    and key == builder.parent.ed.ename then
                return builder.parent
            end
            return nil
        end
    })
    builder.rightTables = setmetatable({}, {__index =
        function(_, key)
            if builder.parent and builder.posInParent == 1 --left
                    and key == builder.parent.ed.ename then
                return builder.parent
            end
            return nil
        end
    })

    local ok, err = ed:_attach(builder)
    if not ok then
        local errMsg = "Failed to subscribe for entity changes topics: "..(err or "")
        ngx.log(ngx.ERR, errMsg)
        return nil, errMsg
    end
    registry[name] = builder
    return builder
end
return VModelBuilder
