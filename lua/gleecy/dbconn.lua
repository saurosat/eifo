---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tnguyen.
--- DateTime: 9/17/23 9:42 AM
---
if not gleecy then
    gleecy = {}
end
if not gleecy.db then
    gleecy.db = {}
end

if gleecy.db.conn then
    return gleecy.db.conn
end
local utils = require "utils"

local RW = {}
RW.__index = utils.newTable(0, 14)
RW.__index.connect = function(self)
    return self.connection:connect(self._host, self._port)
end
RW.__index.disconnect = function(self)
    return self.connection:set_keepalive(self._timeout, self._poolsize)
end
RW.__index.rollback = function(self)
    local _rollback = self._rollback
    --  execute undo functions in _rollback
    while _rollback:len() > 0 do
        local undo = _rollback:pop()
        pcall(undo.f, table.unpack(undo.params))
    end
end
RW.__index.commit = function(self)
    -- reset rollback stack:
    self._rollback:reset()
end
RW.__index.lget = function(self, key, startPos, endPos)
    return self.connection:lrange(key, startPos, endPos)
end
RW.__index.hget = function(self, key, fields)
    if not fields or #fields == 0 then
        return self:hgetall(key)
    end
    local vals, err = self.connection:hmget(key, table.unpack(fields))
    if not vals then
        return nil, err
    end

    if not vals or #vals == 0 then
        return {}
    else
        local svals = ""
        for i = 1, #vals, 1 do
            if vals[i] then
                svals = svals..", "..type(vals[i])
            else
                svals = svals..", nil"
            end
        end
    end
    local retTbl = utils.newTable(0, #fields)
    for i = 1, #fields, 1 do
        retTbl[fields[i]] = vals[i]
    end
    return retTbl
end
RW.__index.hgetall = function(self, key)
    return utils.listToHash(self.connection:hgetall(key))
end
RW.__index.lgetall = function(self, key)
    return self:lget(key, 0, -1)
end
RW.__index.sgetall = function(self, key)
    return self.connection:smembers(key)
end
RW.__index.getall = function(self, key)
    local v
    local vType = self.connection:type(key)
    if vType == "string" then
        v = self.connection:get(key)
    elseif vType == "list" then
        v = self:lgetall(key)
    elseif vType == "set" then
        v = self:sgetall(key)
    elseif vType == "hash" then
        v = self:hgetall(key)
    else
        return nil, vType, "Type " .. vType .. " is not supported"
    end
    return v, vType
end
RW.__index.hset = function(self, key, hashValue, autocommit)
    local fields = utils.keys(hashValue)
    local newVals = utils.newTable(0, #fields) -- malloc for a table with size = #fields
    local oldVals = self:hget(key, fields) or {}

    for i = #fields, 1, -1 do
        local k = fields[i]
        local v = hashValue[k]
        if not oldVals[k] or oldVals[k] ~= v then
            -- different:
            newVals[k] = v
        else
            -- if equal
            oldVals[k] = nil -- remove from oldVals
            table.remove(fields, i) -- remove from fields
        end
    end

    if #fields == 0 then
        return {} -- no differences found. Ignored update
    end
    local ok, err = self.connection:hmset(key, newVals)
    if not ok then
        return nil, err
    end
    if not autocommit then
        self._rollback:push({f = RW.__index.hdel, params = {self, key, fields, true}})
    end
    return oldVals
end
RW.__index.hdel = function(self, key, fields, autocommit)
    local curvals = self:hget(key, fields)
    if not curvals or utils.isTableEmpty(curvals) then
        return {}
    end
    local num
    if fields then
        num = self.connection:hdel(key, table.unpack(fields))
    else
        num = self.connection:del(key)
    end
    if num == 0 then
        err = "Can not delete key '"..key.."'"
        if fields then err = err..", fields: "..table.concat(fields, ",") end
        return nil, err
    end
    if not autocommit then
        self._rollback:push({f = RW.__index.hset, params = {self, key, curvals, true}})
    end
    return curvals
end
RW.__index.sadd = function(self, key, item, autocommit)
    local num = self.connection:sadd(key, item)
    if not autocommit and num > 0 then
        self._rollback:push({f = RW.__index.sremove, params = {self, key, item, true}})
    end
    return num
end
RW.__index.sremove = function(self, key, item, autocommit)
    local num = self.connection:srem(key, item)
    if not autocommit and num > 0 then
        self._rollback:push({f = RW.__index.sadd, params = {self, key, item, true}})
    end
    return num
end
RW.__index.sismember = function(self, key, item)
    return self.connection:sismember(key, item)
end

local redisAgent = require "resty.redis"
gleecy.db.conn = {
    redis = function()
        local ngx = ngx
        local connection = redisAgent:new()
        connection:set_timeouts(timeout)
        return setmetatable({
            _host = ngx.var.dbhost,
            _port = ngx.var.dbport,
            _poolsize = ngx.var.poolsize,
            _timeout = ngx.var.timeout,
            _rollback = utils.lifo(),
            connection = connection
        }, RW)
    end
}
return gleecy.db.conn