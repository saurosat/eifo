---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tnguyen.
--- DateTime: 9/17/23 1:18 PM
---
if not gleecy then
    gleecy = {}
end
if not gleecy.db then
    gleecy.db = {}
end
if gleecy.db.ed then
    return gleecy.db.ed
end
local utils = require "utils"
local _EV = {}
_EV.__index = {
    load = function(self, conn)
        self.oldVals = conn:hgetall(self.key) or {}
        local _, hlen = utils.tbllen(self.oldVals)
        self.values = self.values or utils.newTable(0, hlen)

        for k, v in pairs(self.oldVals) do
            if not self.values[k] or self.values[k] == v then
                self.values[k] = v
                self.oldVals[k] = nil
            end
        end
        self.dirty = not utils.isTableEmpty(self.oldVals)
        return self.oldVals
    end,
    save = function(self, conn, nocommit)
        local oldVals, err = conn:hset(self.key, self.values)
        if not oldVals then return nil, err end
        local sKey
        local insert = utils.isTableEmpty(oldVals)
        if insert then -- case insert:
            sKey = "new:"..self.prefix
        else -- case update:
            sKey = "set:"..self.prefix
        end
        local num = conn:sadd(sKey, self.key)
        if num == 0 then
            num = conn:sismember(sKey, self.key)
        end
        if num == 0 then
            err = "Cannot add tracking key "..sKey
        else
            _, err = conn:hset("set:"..self.key, oldVals) -- keep track of oldVals
        end
        if err then
            if not nocommit then
                conn:rollback()
            end
            return nil, err
        end
        if not nocommit then
            conn:commit()
        end
        return oldVals
    end,
    delete = function(self, conn, nocommit)
        return self:deleteFields(conn, nocommit)
    end,
    deleteFields = function(self, conn, fields, nocommit)
        local oldVals, err = conn:hdel(self.key, fields)
        if not oldVals then return nil, err end
        local sKey = "del:"..self.prefix
        local num = conn:sadd(sKey, self.key)
        if num == 0 then
            num = conn:sismember(sKey, self.key)
        end
        if num == 0 then
            err = "Cannot add tracking key "..sKey
        else
            _, err = conn:hset("del:"..self.key, oldVals) -- keep track of oldVals
        end
        if err then
            if not nocommit then
                conn:rollback()
            end
            return nil, err
        end
        if not nocommit then
            conn:commit()
        end
        return oldVals
    end
}
local _ED = {}
_ED.__index = {
    new = function(self, entityData)
        local idFields = self.fnIds
        if not idFields or #idFields == 0 then
            return nil, "Definition for entity "..entityName.." is invalid: No ID fields defined"
        end

        local key = self.prefix
        for i = 1, #idFields do
            local eId = entityData[idFields[i]]
            if not eId then
                return nil, "ID field "..idFields[i].." is missing"
            end
            key = key..":"..eId
        end

        local persistAction = 0 -- no action
        if utils.popKey(entityData, "delete") then
            persistAction = 1 -- DELETE
        end
        return setmetatable( {schema = self, prefix = self.prefix, key = key,
                              values = entityData, persistAction = persistAction}, _EV)
    end
}
gleecy.db.ed = {
    ProductCategory = setmetatable({
        prefix = "c",
        fnIds = {"productCategoryId"}, --ID field names
        fnFKs = {productCategoryTypeEnumId = "enum:ct"} -- Foreign key field names
    }, _ED),
    Product = setmetatable({
        prefix = "p",
        fnIds = { "productId" },
        fnFKs = {}
    }, _ED),
    ProductCategoryRollup = setmetatable({
        prefix = "c2c",
        fnIds = {"productCategoryId", "parentProductCategoryId"},
        fnFKs = {productCategoryId = "c", parentProductCategoryId = "c"}
    }, _ED),
    ProductCategoryMember = setmetatable({
        prefix = "c2p",
        fnIds = {"productCategoryId", "productId", "fromDate"},
        fnFKs = {productCategoryId = "c", productId = "p"}
    }, _ED),
    ProductStorePromotion = setmetatable({
        prefix = "promo",
        fnIds = {"storePromotionId"},
        nFKs = {}
    }, _ED),
}

--function saveEntity(entity, conn)
--    local entityName = utils.popKey(entity, "entityName")
--    if not entityName then
--        return nil, "Entity Name is expected with key 'entityName'"
--    end
--    local entityDef = gleecy.db.ed[entityName]
--    if not entityDef then
--        return nil, "Entity '" .. entityName .."' has no definition"
--    end
--    local ok, err = conn:connect()
--    if not ok then
--        return nil, "failed to connect to DB: "..err
--    end
--    ok, err = entityDef:save(entity, conn)
--    conn:disconnect()
--    return ok, err
--end
--
--local _mtFK = {}
--_mtFK.__index = {
--    save = function(self, conn, toKey)
--        local ok, err = conn:srem(self.frRelKey, self.toKey)
--        if not ok then return nil, err end
--        return conn:sadd(self.frRelKey, toKey)
--    end
--}
--gleecy.db.ed.relation = {
--    fk = function(frKey, toKey, toPrefix)
--        return setmetatable({
--            frKey = frKey,
--            toKey = toKey,
--            toPrefix = toPrefix,
--            frRelKey = frKey..":"..toPrefix
--        }, _mtFK)
--    end
--}

return gleecy.db.ed
