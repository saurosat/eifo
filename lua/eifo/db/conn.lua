---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tnguyen.
--- DateTime: 9/17/23 9:42 AM
---
local utils = eifo.utils

local rwmt = utils.newTable(0, 18)
rwmt.connect = function(self)
    return self.connection:connect(self._host, self._port)
end
rwmt.disconnect = function(self)
    return self.connection:set_keepalive(self._timeout, self._poolsize)
end
rwmt.rollback = function(self)
    local _rollback = self._rollback
    --  execute undo functions in _rollback
    while _rollback:len() > 0 do
        local undo = _rollback:pop()
        pcall(undo.f, table.unpack(undo.params))
    end
end
rwmt.commit = function(self)
    -- reset rollback stack:
    self._rollback:reset()
end
rwmt.incr = function(self, key)
    return self.connection:incr(key)
end
rwmt.decr = function(self, key)
    return self.connection:decr(key)
end
rwmt.set = function(self, key, value, overwrite)
    return overwrite and self.connection:set(key, value)
            or self.connection:setnx(key, value)
end
rwmt.getdel = function(self, key)
    return self.connection:getdel(key)
end

rwmt.lget = function(self, key, startPos, endPos)
    return self.connection:lrange(key, startPos, endPos)
end
rwmt.hget = function(self, key, fields)
    if not fields or #fields == 0 then
        return self:hgetall(key)
    end
    local vals, err = self.connection:hmget(key, table.unpack(fields))
    if not vals then
        return nil, err
    end

    if not vals or #vals == 0 then
        return {}
    end
    local retTbl = utils.newTable(0, #fields)
    for i = 1, #fields, 1 do
        if type(vals[i]) ~= "userdata" then
            retTbl[fields[i]] = vals[i]
        end
    end
    return retTbl
end
rwmt.hgetall = function(self, key)
    return utils.listToHash(self.connection:hgetall(key))
end
rwmt.lgetall = function(self, key)
    return self:lget(key, 0, -1)
end
rwmt.sgetall = function(self, key)
    return self.connection:smembers(key)
end
rwmt.hset = function(self, key, hashValue, autocommit)
    --ngx.log(ngx.DEBUG, "hset Input: \n"..utils.toString(hashValue, ": ", "\n"))
    local fields = utils.keys(hashValue)
    if #fields == 0 then
        return nil, "Cannot save: input hash table is empty"
    end
    fields[#fields + 1] = "version"
    local oldVals = self:hget(key, fields)
    fields[#fields] = nil
    local newVals
    local newVersion = 1
    --ngx.log(ngx.DEBUG, "OldVals: \n"..utils.toString(oldVals, ": ", "\n"))
    local newFields = {} -- keeps fields that is currently empty
    local delFields = {} -- Fields to be deleted
    if not oldVals or utils.isTableEmpty(oldVals) then
        hashValue["version"] = 1
        newVals = hashValue
    else
        newVersion = (oldVals["version"] or 1) + 1 -- default 1 for backward compatibility
        newVals = utils.newTable(0, #fields) -- malloc for a table with size = #fields
        for i = #fields, 1, -1 do
            local k = fields[i]
            local v = hashValue[k]
            if not oldVals[k] then
                newFields[#newFields] = k
                newVals[k] = v
            elseif oldVals[k] ~= v then -- different:
                if v == "_NA_" then
                    delFields[#delFields+1] = k
                else
                    newVals[k] = v
                end
            else -- if equal :
                oldVals[k] = nil -- remove from oldVals
                table.remove(fields, i) -- remove from fields
            end
        end
        if not utils.isTableEmpty(newVals) then
            newVals["version"] = newVersion
            hashValue["version"] = newVersion
        end
    end

    if #fields == 0 then
        return {} -- no differences found. Ignored update
    end
    --ngx.log(ngx.DEBUG, "hmset params: "..utils.toString(newVals, ": ", "\n"))
    local ok, err
    if #delFields > 0 then
        ok, err = self.connection:hdel(key, table.unpack(delFields))
        if not ok then
            return nil, err
        end
    end
    ok, err = self.connection:hmset(key, newVals)
    if not ok then
        return nil, err
    end
    if not autocommit then
        if not oldVals or utils.isTableEmpty(oldVals) then
            self._rollback:push({f = rwmt.hdel, params = {self, key, fields, true}})
        else
            self._rollback:push({f = rwmt.hset, params = {self, key, oldVals, true}})
            self._rollback:push({f = rwmt.hdel, params = {self, key, newFields, true}})
        end
    end
    return oldVals, nil, newVals
end
rwmt.hdel = function(self, key, fields, autocommit)
    local curvals = self:hgetall(key)
    if not curvals or utils.isTableEmpty(curvals) then
        return nil, "Cannot delete, key not found: "..key
    end
    local oldVals
    local deleteAll
    local version
    if not fields then
        oldVals = curvals
        deleteAll = true
    else
        if #fields == 0 then
            return {}, nil --not delete any field
        end
        oldVals = utils.newTable(0, #fields)
        for i = 1, #fields, 1 do
            oldVals[fields[i]] = curvals[fields[i]]
            curvals[fields[i]] = nil
        end
        version = curvals["version"]
        if version ~= nil then
            local _, numRemainedFields = utils.tbllen(curvals)
            if numRemainedFields <= 2 then
                -- all fields is subjected to delete, should delete field 'version' as well:
                deleteAll = true
                fields[#fields] = "version" -- add 'version' to field list
                oldVals["version"] = version
                curvals["version"] = nil
                oldVals["key"] = curvals["key"]
                curvals["key"] = nil
            else
                deleteAll = false
                oldVals["version"] = version
                version = version + 1
                curvals["version"] = version
            end
        else
            -- 'version' not exist in curvals, mean that it's been moved to oldVals
            -- ==> given fields contain 'version'
            deleteAll = true
            for k, v in pairs(curvals) do -- prepare to delete all
                -- move all remaining to oldVals
                oldVals[k] = v
                curvals[k] = nil
                fields[#fields] = k -- copy field to delete
            end
        end
    end
    local num
    if deleteAll then
        num = self.connection:del(key)
    else
        num = self.connection:hset(key, "version", version + 1)
        num = self.connection:hdel(key, table.unpack(fields))
    end
    if num == 0 then
        local err = "Can not delete key '"..key.."'"
        if fields then err = err..", fields: "..table.concat(fields, ",") end
        return nil, err
    end
    if not autocommit then
        self._rollback:push({f = rwmt.hset, params = {self, key, oldVals, true}})
    end
    return oldVals, nil, curvals
end
rwmt.sadd = function(self, key, item, autocommit)
    if not item then
        return 0
    end
    local num, err = self.connection:sadd(key, item)
    if not num then
        ngx.log(ngx.ERR, "SADD Key="..(key or "NIL")..", item="..(item or "NIL").." "..(err or ""))
        return 0, err
    end
    if not autocommit and  num > 0 then
        self._rollback:push({f = rwmt.sremove, params = {self, key, item, true}})
    end
    return num
end
rwmt.sremove = function(self, key, item, autocommit)
    local num, err = self.connection:srem(key, item)
    if not num then
        ngx.log(ngx.INFO, "Delete failed, key="..key..", keyItem="..(item or "NIL").." is not found. "..(err or ""))
        return 0, err
    end
    if not autocommit and num > 0 then
        self._rollback:push({f = rwmt.sadd, params = {self, key, item, true}})
    end
    return num
end
rwmt.sismember = function(self, key, item)
    return self.connection:sismember(key, item)
end
setmetatable(rwmt, {__index = function(self, cmdName)  
    local cmd = function(self, ...)
        return self.connection[cmdName](self, ...)
    end
    rwmt[cmdName] = cmd
    return cmd
end})
local RW = {
    __index = rwmt
}

local redisAgent = require "resty.redis"

local connFactory = {
    host = "127.0.0.1",
    port = "6379",
    poolsize = 100,
    timeout = 10000,
    redis = function(host, port, poolsize, timeout)
        local ngx = ngx
        host = host or eifo.db.host or ngx.var.dbhost
        port = port or eifo.db.port or ngx.var.dbport
        poolsize = poolsize or eifo.db.poolsize or ngx.var.poolsize
        timeout = timeout or eifo.db.timeout or ngx.var.timeout
        local connection, err = redisAgent:new()
        if not connection then
            local errMsg = "Can not initialized DB connection "+ ": " + (err or "Unknown error")
            error(errMsg, ngx.ERR)
        end
        connection:set_timeouts(timeout)
        local dbconn = {
            _host = host,
            _port = port,
            _poolsize = poolsize,
            _timeout = timeout,
            _rollback = utils.lifo(),
            connection = connection
        }
        setmetatable(dbconn, RW)
        return dbconn
    end
}

return connFactory