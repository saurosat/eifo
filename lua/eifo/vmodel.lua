---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tnguyen.
--- DateTime: 12/10/23 10:29 AM
---

---
--- view model
--- similar to VIEW in SQL
--- Keep a left join vmodel and right join vmodel, each one can have other vmodels joined
---     1. each leftVModel should keep a ref to self in __index to prevent infinite loop
---     2. each rightVModel is similar
---     3. Many-To-One FK field to be replaced by a ref to a record in leftVModel
---     4. One-To-Many field to be replaced by a list of records in rightTables
---     5. Currently support only 3 methods of loading records: i. loadOne (using key),
--- ii. loadAll and iii. loadByFK: load by a Many-To-Ond FK value, such as load all products
--- of a category. The next step is to support query and full text search
---     6. there are two options for the mechanism to update view:
---         i. Each view maintain 1 JSON file to store data about entities that related to
---              rendered files. When rendering, append to that file. When updating, load all file
---              then delete all, then put back unchanged file info and append rerendered file info
---         ii. The topic includes 3 info: ED name, Field name and key.
---         Because views are stored in memory, scan through all view and check if its model is related
---         to the topic ED name and column. If yes, calculate the outPathFile and delete if it exists
---         For each view, get main model:
---             + If topic ED name is the main ED: check key
---             + If topic ED name is belong to Left: create model of topicED, then
---              loadRights for main ED name then delete all files of found keys
---             + If topic ED name belong to Right, create model of topic ED then join left to find
---             out the affected key
---         Because each view can only attach with 1 main entity, we can find the direct views affected
---         Then we can create a full model (with all possible left and right joins) to find other
---          affected views
---         NOTE: with this solution, the main ed of model should have only one record, otherwise,
---         there is no way to calculate outFileName
---         For the case of index page, we have to make a 'index' virtual ED in dao.lua, and create FK
---         in other EDs (Category) to it
---
if not eifo then
    eifo = {}
end
if eifo.VModelBuilder then
    return eifo.VModelBuilder
end
local ED = require("eifo.dao")
local utils = require("eifo.utils")
local eval = loadstring
local setmetatable = setmetatable
local ngx = ngx

local function addColumns(selfClass, ...)
    local columns = {...}
    local numCols = #columns
    if numCols == 0 then
        return selfClass
    end

    local selfColumns = selfClass.columns
    local numSelfCols = #selfColumns
    local col
    for i = 1, numCols, 1 do
        col = columns[i]
        for j = 1, numSelfCols, 1 do
            if col == selfColumns[j] then
                col = nil
                break
            end
        end
        if col then
            numSelfCols = numSelfCols + 1
            selfColumns[numSelfCols] = col
        end
    end
    return selfClass
end
local function addFilter(selfClass, condition, fKeyColumn)
    local sFunction = "local f = function(entity) return "..condition.." end return f"
    local fCondition = assert(eval(sFunction))()
    local filters = (fKeyColumn and selfClass.leftCols[fKeyColumn]) or selfClass.filters
    filters[#filters + 1] = function(ev)
        return fCondition(ev)
    end
    return selfClass
end
local function addVModel(self, vModel, pos)
    local modelEName = vModel.ed.ename
    if pos > 0 then
        self.leftTables[modelEName] = vModel
    else
        self.rightTables[modelEName] = vModel
    end
    vModel.parent = self
    vModel.posInParent = pos
    ngx.log(ngx.DEBUG, "Reference to self is "
            ..(((self.leftTables[modelEName] or self.rightTables[modelEName]) and "OK") or "Failed"))
    return vModel
end
local function leftJoin(selfClass, fKeyColumn, aliasForFkObj, onCondition,...)
    local selfEName = selfClass.ed.ename
    local edFKs = selfClass.ed.fnFKs;
    local fkEName = edFKs[fKeyColumn]
    if not fkEName then
        local errMsg = "Entity '"..selfEName.."' does not have FK column "..fKeyColumn
        ngx.log(ngx.ERR, errMsg)
        return nil, errMsg
    end
    if selfClass.leftCols[fKeyColumn] then
        return selfClass.leftTables[fkEName]
    end

    ngx.log(ngx.DEBUG, "Adding Left join "..selfEName.." TO "..fkEName)

    local vModel, err = selfClass.leftTables[fkEName], nil
    if not vModel then
        vModel, err = eifo.VModelBuilder.new(nil, fkEName)
        if vModel then
            addVModel(selfClass, vModel, 1)
        end
    end
    if not vModel then
        ngx.log(ngx.ERR, err)
        return nil, err
    end

    vModel:addColumns(...)
    vModel.rightCols[aliasForFkObj] = {selfClass.ed.ename, fKeyColumn}
    vModel.toParentCol = aliasForFkObj
    selfClass.leftCols[fKeyColumn] = {eName = vModel.ed.ename}
    return vModel
end
local function rightJoin(selfClass, eName, fKeyColumn, alias, onCondition,...)
    if selfClass.rightCols[alias] then
        return selfClass.rightTables[eName]
    end
    local ed = ED[eName]
    if not ed then
        local errMsg = "Entity name '".. eName .."' not found "
        ngx.log(ngx.ERR, errMsg)
        return nil, errMsg
    end
    local selfEName = ed.fnFKs[fKeyColumn]
    if not selfEName or selfEName ~= selfClass.ed.ename then
        local errMsg = "Entity name '"..eName.."' does not have FK relationship to "..selfClass.ed.ename
        ngx.log(ngx.ERR, errMsg)
        return nil, errMsg
    end

    local vModel, err = selfClass.rightTables[eName], nil
    if vModel and vModel.leftCols[fKeyColumn] then
        return vModel
    end

    ngx.log(ngx.DEBUG, "Adding Right join "..selfClass.ed.ename.." TO "..eName)
    if not vModel then
        vModel, err = eifo.VModelBuilder.new(nil, eName)
        if vModel then
            addVModel(selfClass, vModel, -1)
        end
    end
    if not vModel then
        ngx.log(ngx.ERR, err)
        return nil, err
    end
    vModel:addColumns(...)
    vModel.leftCols[fKeyColumn] = {eName = selfClass.ed.ename}
    vModel.toParentCol = fKeyColumn
    if onCondition then
        vModel:addFilter(onCondition, fKeyColumn)
    end
    selfClass.rightCols[alias] = {eName, fKeyColumn}
    return vModel
end

--- Look for vModel that having given main Entity Definition
--- return the found vmodel and paths to it from original entity 
local function lookup(self, paths, ev)
    local resultPaths = paths or {}
    local selfEName = self.ed.ename
    ngx.log(ngx.DEBUG, "START Entity: "..selfEName..". "..table.concat(resultPaths, ", "))
    local eName = ev.ed.ename
    if selfEName == eName then
        local cols = self.columns
        local numCols = #cols
        if numCols == 0 then
            return self
        end
        for i = 1, numCols do
            if ev[cols[i]] then
                return self
            end
        end
        return nil, resultPaths
    end
    -- Check lefts and rights before recursion for better performance
    if self.leftTables[eName] then
        resultPaths[#resultPaths + 1] = eName -- Odd index for left
        resultPaths[#resultPaths + 1] = "" -- Even index for right. Use empty string instead of nil to make the array expand
        return self.leftTables[eName]:lookup(resultPaths, ev)
    end
    if self.rightTables[eName] then
        resultPaths[#resultPaths + 1] = "" -- Odd index for left. Use empty string instead of nil to make the array expand
        resultPaths[#resultPaths + 1] = eName -- Even index for right.
        return self.rightTables[eName]:lookup(resultPaths, ev)
    end
    ngx.log(ngx.DEBUG, selfEName.."'s Left entities:")
    local vModels = self.leftTables
    for k, v in pairs(vModels) do
        --if k ~= resultPaths[#resultPaths] then --> check last path from Right to avoid infinite loop
            -- Add path to this node (Assume that result will be found here)
            resultPaths[#resultPaths + 1] = k  -- Odd index for left.
            resultPaths[#resultPaths + 1] = ""
            local vModel, paths = v:lookup(resultPaths, ev)
            if vModel then
                return vModel, paths
            end
            -- Not found. revert the path back (Delete two array items that have been added above)
            resultPaths[#resultPaths] = nil
            resultPaths[#resultPaths] = nil
        --end
    end
    ngx.log(ngx.DEBUG, "END "..selfEName.."'s Left entities.")
    ngx.log(ngx.DEBUG, selfEName.."'s Right entities: ")
    vModels = self.rightTables
    for k, v in pairs(vModels) do
        --if k ~= resultPaths[#resultPaths - 1] then --> check last path from Left to avoid infinite loop
            -- Add path to this node (Assume that result will be found here)
            resultPaths[#resultPaths + 1] = ""
            resultPaths[#resultPaths + 1] = k  -- Even index for right.
            local vModel, paths = v:lookup(resultPaths, ev)
            if vModel then
                return vModel, paths
            end
            -- Not found. revert the path back (Delete two array items that have been added above)
            resultPaths[#resultPaths] = nil
            resultPaths[#resultPaths] = nil
        --end
    end
    ngx.log(ngx.DEBUG, "END "..selfEName.."'s Right entities. ")
    ngx.log(ngx.DEBUG, "END Entity: "..selfEName.."___________________________________")
    -- Not found any where in this node
    return nil, resultPaths
end
---
--- The paths params will be visit from tail
local function traverseBack(self, paths)
    if #paths == 0 then
        return self
    end
    local vModel = nil
    local eName = paths[#paths]
    paths[#paths] = nil -- remove last item
    -- traversing backward hence even is LEFT, odd is RIGHT
    if eName == "" then -- even is empty.
        eName = paths[#paths] -- odd. even is empty ==> odd must not empty.
        vModel = self.rightTables[eName] -- odd is RIGHT
    else -- even not empty
        vModel = self.leftTables[eName] -- even is LEFT
    end
    paths[#paths] = nil -- remove second-last item
    assert(vModel ~= nil)
    return vModel:traverseBack(paths)
end
local function traceBack(self)
    local curNode = self
    while curNode.parent do
        curNode = curNode.parent
    end
    return curNode
end
local function _update(selfClass, ev, oldVals)
    ngx.log(ngx.DEBUG, "VModelBuilder '"..selfClass.name.."' UPDATING: \r\n"
            ..utils.toString(ev, ": ", "\r\n"))
    if not ev.key then
        local ok, err = ev:resetKey()
        if not ok then
            return ok, err
        end
    end
    local vModel = selfClass:newVModel(true)
    local conn = require("eifo.dbconn").redis()
    conn:connect()
    local vRecord, err = vModel:loadByKey(ev.values.key, conn, true)
    conn:disconnect()
    if not vRecord then
        local errMsg = "Can not find entity while updating for key '"
            ..ev.key.."'. Please check maxLevel setting"..err
        ngx.log(ngx.CRIT, errMsg)
        return nil, errMsg
    end
    local topVModel = vModel:traceBack()
    topVModel:_notify(oldVals)
    return topVModel
end

local function getRecord(selfInstance, key, conn)
    local record = selfInstance.keys[key]
    if not record and conn then
        return selfInstance:loadByKey(key, conn)
    end
    return record
end
local function loadByIds(selfInstance, ids, conn, reversed)
    if selfInstance._level >= selfInstance.maxLevel then
        return nil    
    end
    selfInstance._level = selfInstance._level + 1
    local eName = selfInstance.ed.ename
    local ev = selfInstance.ed[eName]:new(ids):load(conn)
    if not ev then
        local err = "Entity IDs ("..table.concat(ids, ", ")..") not found in "..eName
        ngx.log(ngx.INFO, err)
        selfInstance._level = selfInstance._level - 1
        return nil, err
    end
    selfInstance._level = selfInstance._level - 1
    return selfInstance:addRecord(ev, conn, reversed)
end
local function loadByKey(selfInstance, key, conn, reversed)
    ngx.log(ngx.DEBUG, selfInstance.ed.ename.."loadByKey '"..key.."', level="..selfInstance._level
            ..", maxLevel="..selfInstance.maxLevel)

    if selfInstance._level >= selfInstance.maxLevel then
        return nil
    end
    selfInstance._level = selfInstance._level + 1
    local ev = selfInstance.ed:get(key, conn)
    if not ev then
        local err = "Entity key '"..key.."' not found in "..selfInstance.ed.ename
        ngx.log(ngx.INFO, err)
        selfInstance._level = selfInstance._level - 1
        return nil, err
    end
    local vRecord = selfInstance:addRecord(ev, conn, reversed)
    selfInstance._level = selfInstance._level - 1
    return vRecord
end
local function filterPassed(record, filters)
    for i = 1, #filters, 1 do
        if not filters[i](record) then
            return false
        end
    end
    return true
end
local function loadByFk(selfInstance, fKeyColumn, fKeyValue, conn, reversed)
    local group = selfInstance.groupBy[fKeyColumn][fKeyValue]
    if group then
        return group
    end
    local joinInfo = selfInstance.leftCols[fKeyColumn]
    if not joinInfo then
        local err = "Join relation is not declared: ".. fKeyColumn
        ngx.log(ngx.ERR, err)
        return nil, err
    end

    if selfInstance._level >= selfInstance.maxLevel then
        return nil
    end
    selfInstance._level = selfInstance._level + 1
    local filters = joinInfo
    local ev = ED[joinInfo.eName]:new({key = fKeyValue}, true)
    local keys = ev:getChildrenIds(selfInstance.ed.ename, conn)
    group = utils.newTable(#keys, 0)
    for i = 1, #keys, 1 do
        local record = selfInstance:getRecord(keys[i])
        if record then
            if not filterPassed(record, filters) then
                record = false
            end
        else
            local childEv = selfInstance.ed:get(keys[i], conn)
            if filterPassed(record, filters) then
                record = selfInstance:addRecord(childEv, conn, reversed)
            end
        end
        if record then
            group[#group + 1] = record
        end
    end
    selfInstance.groupBy[fKeyColumn][fKeyValue] = group
    selfInstance._level = selfInstance._level - 1
    return group
end

local function addRecord(selfInstance, ev, conn, reversed)
    -- unchecked: ev should be of type selfInstance.ed
    -- Apply filters
    if not filterPassed(ev.values, selfInstance.filters) then
        ngx.log(ngx.DEBUG, ev.key..": filtered out")
        return nil
    end

    -- process Entity Values
    local values = ev.values
    local cols = selfInstance.columns
    local numCols = (cols and #cols) or 0
    local vRecord = setmetatable({}, {
        __index = function(tbl, key)
            local rightInfo = selfInstance.rightCols[key]
            if rightInfo then
                local vModel = selfInstance.rightTables[rightInfo[1]] --> rightInfo[1] is table name
                local groupBy = vModel.groupBy[rightInfo[2]] --> rightInfo[2] is joined column name
                return groupBy[tbl.key]
            end
            return nil
        end})
    if numCols > 0 then
        for i = 1, numCols, 1 do
            vRecord[cols[i]] = values[cols[i]]
        end
        vRecord["key"] = values["key"]
        local ids = ev.ed.fnIds
        for i = 1, #ids, 1 do
            vRecord[ids[i]] = values[ids[i]]
        end
    else
        for k, v in pairs(values) do
            vRecord[k] = v
        end
    end
    selfInstance[#selfInstance + 1] = vRecord
    selfInstance.keys[vRecord.key] = vRecord

    if not reversed then
        -- process left joined columns:
        local leftCols = selfInstance.leftCols
        for k, v in pairs(leftCols) do
            local vModel = selfInstance.leftTables[v.eName]
            local fkVRecord = vModel:getRecord(vRecord[k], conn)
            if fkVRecord then
                vRecord[k] = fkVRecord
            end
        end
        -- process right joined columns:
        local rightCols = selfInstance.rightCols
        for k, v in pairs(rightCols) do
            ngx.log(ngx.DEBUG, selfInstance.ed.ename.." right join to "..v[1]..", column "..v[2])
            local vModel = selfInstance.rightTables[v[1]] --> v[1] is table name
            vModel:loadByFk(v[2], vRecord.key, conn)
        end
    else
        local parent = selfInstance.parent
        if not parent then --> self is the main vmodel
            return vRecord
        end
        local fkCol = selfInstance.toParentCol
        if not fkCol  then
            local errMsg = "FK column linked to parent vModel is not set"
            ngx.log(ngx.ERR, errMsg)
            -- logically, in case of error, the result should not be added
            selfInstance[#selfInstance] = nil
            selfInstance.keys[vRecord.key] = nil
            return nil, errMsg
        end
        local posInParent = selfInstance.posInParent
        if not fkCol or not posInParent then
            local errMsg = "Parent position is not set"
            ngx.log(ngx.ERR, errMsg)
            -- logically, in case of error, the result should not be added
            selfInstance[#selfInstance] = nil
            selfInstance.keys[vRecord.key] = nil
            return nil, errMsg
        end
        if posInParent == -1 then
            local passed = filterPassed(vRecord, selfInstance.leftCols[fkCol])
            if not passed then --> this record does not affect parent record
                return nil
            end
            local key = vRecord[fkCol]
            if not key then --> this record does not affect parent record
                return nil
            end
    
            parent:loadByKey(key, conn, reversed)
        else
            local rightInfo = selfInstance.rightCols[fkCol]
            if not rightInfo then
                local errMsg = "Alias column linked to parent vModel is not set"
                ngx.log(ngx.ERR, errMsg)
                -- logically, in case of error, the result should not be added
                selfInstance[#selfInstance] = nil
                selfInstance.keys[vRecord.key] = nil
                return nil, errMsg
            end
            parent:loadByFK(rightInfo[2], vRecord.key, conn, reversed)
        end
    end

    return vRecord
end

local __instance = utils.newTable(0, 6)
__instance.lookup = lookup
__instance.traverseBack = traverseBack
__instance.traceBack = traceBack
__instance.getRecord = getRecord
__instance.addRecord = addRecord
__instance.loadByKey = loadByKey
__instance.loadByIds = loadByIds
__instance.loadByFk = loadByFk
__instance._notify = utils.observable._notify


local function newVModel(selfClass, reversed)
    local instance = setmetatable(utils.newTable(50, 11), {
        __index = __instance
    })
    instance._observers = selfClass._observers --> this will be created in selfClass when first observer attach
    if instance._observers then
        for id, observer in pairs(instance._observers) do
            ngx.log(ngx.DEBUG, "instance's observer '"..id.."': "..utils.toString(observer, ": ", "\r\n"))
        end
    end

    instance.ed = selfClass.ed
    if instance.ed._observers then
        for id, observer in pairs(instance.ed._observers) do
            ngx.log(ngx.DEBUG, "ED's observer '"..id.."': "..utils.toString(observer, ": ", "\r\n"))
        end
    end
    instance.maxLevel = selfClass.maxLevel
    instance._level = 0
    instance.columns = selfClass.columns
    instance.filters = selfClass.filters
    instance.leftCols = selfClass.leftCols
    instance.rightCols = selfClass.rightCols
    instance.toParentCol = selfClass.toParentCol

    instance.keys = {}
    instance.groupBy = {}
    for k, _ in pairs(selfClass.leftCols) do
        instance.groupBy[k] = {}
    end

    if reversed then
        if selfClass.parent then
            instance.parent = selfClass.parent:newVModel(reversed)
            instance.posInParent = selfClass.posInParent
            end
        return instance
    end

    instance.leftTables = setmetatable({}, {
        __index = function(_, key)
            if instance.parent and instance.posInParent == -1 -- right
                    and key == instance.parent.ed.ename then
                        ngx.log(ngx.DEBUG, "Left table metamethod invoked")
                        return instance.parent
            end
            return nil
        end
    })
    instance.rightTables = setmetatable({}, {
        __index = function(_, key)
            if instance.parent and instance.posInParent == 1 -- left
                    and key == instance.parent.ed.ename then
                ngx.log(ngx.DEBUG, "Right table metamethod invoked")
                return instance.parent
            end
            return nil
        end
    })

    ngx.log(ngx.DEBUG, "Copying Left tables of "..instance.ed.ename)
    for k, v in pairs(selfClass.leftTables) do
        ngx.log(ngx.DEBUG, "+ k = "..k..", v = "..(v.ed and v.ed.ename or "No ED"))
        local vModel = v:newVModel()
        vModel.parent = instance
        vModel.posInParent = 1
        instance.leftTables[k] = vModel
    end
    ngx.log(ngx.DEBUG, "Copying Right tables of "..instance.ed.ename)
    for k, v in pairs(selfClass.rightTables) do
        ngx.log(ngx.DEBUG, "+ k = "..k..", v = "..(v.ed and v.ed.ename or "No ED"))
        local vModel = v:newVModel()
        vModel.parent = instance
        vModel.posInParent = -1
        instance.rightTables[k] = vModel
    end
    for k, v in pairs(instance.leftTables) do
        ngx.log(ngx.DEBUG, "Instance Left tables "..instance.ed.ename..": k = "..k..", v = "..v.ed.ename)
    end
    for k, v in pairs(instance.rightTables) do
        ngx.log(ngx.DEBUG, "Instance Right tables: "..instance.ed.ename.." k = "..k..", v = "..v.ed.ename)
    end

    ngx.log(ngx.DEBUG, "Done "..instance.ed.ename)
    return instance
end
local __vMClass = utils.newTable(0, 9)
__vMClass.addColumns = addColumns
__vMClass.addFilter = addFilter
__vMClass.leftJoin = leftJoin
__vMClass.rightJoin = rightJoin
__vMClass.lookup = lookup
__vMClass.newVModel = newVModel
__vMClass._attach = utils.observable._attach
__vMClass._detach = utils.observable._detach
__vMClass._update = _update

eifo.VModelBuilder = {
    registry = {},
    new = function(name, eName, ...)
        local ed = ED[eName]
        if not ed then
            return nil, "Unknown entity name "..eName
        end
        local registry = eifo.VModelBuilder.registry
        if not name then
            name = eName
            local i = 1
            while registry[name] do
                name = eName.."#"..i
                i = i + 1
            end
        end
        local builder = {
            name = name,
            _observerId = name,
            maxLevel = 100,
            ed = ed,
            columns = {...},
            leftCols = {},
            rightCols = {},
            filters = {},
        }
        setmetatable(builder, { __index = __vMClass })
        builder.leftTables = setmetatable({}, {__index =
            function(_, key)
                if builder.parent and builder.posInParent == -1  --right
                        and key == builder.parent.ed.ename then
                    return builder.parent
                end
                return nil
            end
        })
        builder.rightTables = setmetatable({}, {__index =
            function(_, key)
                if builder.parent and builder.posInParent == 1 --left
                        and key == builder.parent.ed.ename then
                    return builder.parent
                end
                return nil
            end
        })

        local ok, err = ed:_attach(builder)
        if not ok then
            local errMsg = "Failed to subscribe for entity changes topics: "..(err or "")
            ngx.log(ngx.ERR, errMsg)
            return nil, errMsg
        end
        registry[name] = builder
        return builder
    end
}
return eifo.VModelBuilder
