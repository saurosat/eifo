---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tnguyen.
--- DateTime: 12/10/23 10:29 AM
---

---
--- view model
--- similar to VIEW in SQL
--- Keep a left join vmodel and right join vmodel, each one can have other vmodels joined
--- TODO:
---     1. each leftVModel should NOT keep a ref to self to prevent infinite loop
---     2. each rightVModel is similar
---     3. Many-To-One FK field to be replaced by a ref to a record in leftVModel
---     4. One-To-Many field to be replaced by a list of records in rightTables
---     5. Currently support only 3 methods of loading records: i. loadOne (using key),
--- ii. loadAll and iii. loadByFK: load by a Many-To-Ond FK value, such as load all products
--- of a category. The next step is to support query and full text search
---     6. there are two options for the mechanism to update view:
---         i. Each view maintain 1 JSON file to store data about entities that related to
---              rendered files. When rendering, append to that file. When updating, load all file
---              then delete all, then put back unchanged file info and append rerendered file info
---         ii. The topic includes 3 info: ED name, Field name and key.
---         Because views are stored in memory, scan through all view and check if its model is related
---         to the topic ED name and column. If yes, calculate the outPathFile and delete if it exists
---         For each view, get main model:
---             + If topic ED name is the main ED: check key
---             + If topic ED name is belong to Left: create model of topicED, then
---              loadRights for main ED name then delete all files of found keys
---             + If topic ED name belong to Right, create model of topic ED then join left to find
---             out the affected key
---         Because each view can only attach with 1 main entity, we can find the direct views affected
---         Then we can create a full model (with all possible left and right joins) to find other
---          affected views
---         NOTE: with this solution, the main ed of model should have only one record, otherwise,
---         there is no way to calculate outFileName
---         For the case of index page, we have to make a 'index' virtual ED in dao.lua, and create FK
---         in other EDs (Category) to it
---
if not eifo then
    eifo = {}
end
if eifo.VModelBuilder then
    return eifo.VModelBuilder
end
local ED = require("eifo.dao")
local utils = require("eifo.utils")
local eval = loadstring
local setmetatable = setmetatable
local ngx = ngx

local function addColumns(selfClass, ...)
    local columns = {...}
    local numCols = #columns
    if numCols == 0 then
        return selfClass
    end

    local selfColumns = selfClass.columns
    local numSelfCols = #selfColumns
    local col
    for i = 1, numCols, 1 do
        col = columns[i]
        for j = 1, numSelfCols, 1 do
            if col == selfColumns[j] then
                col = nil
                break
            end
        end
        if col then
            numSelfCols = numSelfCols + 1
            selfColumns[numSelfCols] = col
        end
    end
    return selfClass
end
local function addFilter(selfClass, condition, fKeyColumn)
    local sFunction = "local f = function(entity) return "..condition.." end return f"
    local fCondition = assert(eval(sFunction))()
    local filters = (fKeyColumn and selfClass.leftCols[fKeyColumn]) or selfClass.filters
    filters[#filters + 1] = function(ev)
        return fCondition(ev)
    end
    return selfClass
end
local function leftJoin(selfClass, fKeyColumn, aliasForFkObj, onCondition,...)
    if selfClass.leftCols[fKeyColumn] then
        return selfClass
    end

    local edFKs = selfClass.ed.fnFKs;
    local fkEName = edFKs[fKeyColumn]
    if not fkEName then
        local errMsg = "Entity '"..selfEName.."' does not have FK column "..fKeyColumn
        ngx.log(ngx.ERR, errMsg)
        return nil, errMsg
    end
    ngx.log(ngx.DEBUG, "Adding Left join "..selfEName.." TO "..fkEName)

    local vModel = selfClass.leftTables[fkEName]
    if not vModel then
        vModel = eifo.VModelBuilder.new(fkEName)
        addVModel(selfClass, vModel, 1)
    end

    vModel:addColumns(...)
    vModel.rightCols[aliasForFkObj] = {selfClass.ed.ename, fKeyColumn}
    selfClass.leftCols[fKeyColumn] = {eName = vModel.ed.ename}
    return selfClass
end
local function addVModel(self, vModel, pos)
    local modelEName = vModel.ed.ename
    if pos > 0 then
        self.leftTables[modelEName] = vModel
    else
        self.rightTables[modelEName] = vModel
    end
    vModel.parent = self
    vModel.posInParent = pos
    ngx.log(ngx.DEBUG, "Reference to self is "
            ..(((self.leftTables[modelEName] or self.rightTables[modelEName]) and "OK") or "Failed"))
    return vModel
end
local function rightJoin(selfClass, eName, fKeyColumn, alias, onCondition,...)
    if selfClass.rightCols[alias] then
        return selfClass
    end
    local ed = ED[eName]
    if not ed then
        local errMsg = "Entity name '".. eName .."' not found "
        ngx.log(ngx.ERR, errMsg)
        return nil, errMsg
    end
    local selfEName = ed.fnFKs[fKeyColumn]
    if not selfEName or selfEName ~= selfClass.ed.ename then
        local errMsg = "Entity name '"..eName.."' does not have FK relationship to "..selfClass.ed.ename
        ngx.log(ngx.ERR, errMsg)
        return nil, errMsg
    end

    local vModel = selfClass.rightTables[eName]
    if vModel and vModel.leftCols[fKeyColumn] then
        return selfClass
    end

    ngx.log(ngx.DEBUG, "Adding Right join "..selfClass.ed.ename.." TO "..eName)
    if not vModel then
        vModel = eifo.VModelBuilder.new(eName)
        addVModel(selfClass, vModel, -1)
    end
    vModel:addColumns(...)
    vModel.leftCols[fKeyColumn] = {eName = selfClass.ed.ename}
    if onCondition then
        vModel:addFilter(onCondition, fKeyColumn)
    end
    selfClass.rightCols[alias] = {eName, fKeyColumn}
    return selfClass
end
--- The paths params will be modified
local function lookup(self, paths, ev)
    local resultPaths = paths or {}
    local selfEName = self.ed.ename
    ngx.log(ngx.DEBUG, "START Entity: "..selfEName..". "..table.concat(resultPaths, ", "))
    local eName = ev.ed.ename
    if selfEName == eName then
        local cols = self.columns
        local numCols = #cols
        if numCols == 0 then
            return self
        end
        for i = 1, numCols do
            if ev[cols[i]] then
                return self
            end
        end
        return nil, resultPaths
    end
    -- Check lefts and rights before recursion for better performance
    if self.leftTables[eName] then
        resultPaths[#resultPaths + 1] = eName -- Odd index for left
        resultPaths[#resultPaths + 1] = "" -- Even index for right. Use empty string instead of nil to make the array expand
        return self.leftTables[eName]:lookup(resultPaths, ev)
    end
    if self.rightTables[eName] then
        resultPaths[#resultPaths + 1] = "" -- Odd index for left. Use empty string instead of nil to make the array expand
        resultPaths[#resultPaths + 1] = eName -- Even index for right.
        return self.rightTables[eName]:lookup(resultPaths, ev)
    end
    ngx.log(ngx.DEBUG, selfEName.."'s Left entities:")
    local vModels = self.leftTables
    for k, v in pairs(vModels) do
        --if k ~= resultPaths[#resultPaths] then --> check last path from Right to avoid infinite loop
            -- Add path to this node (Assume that result will be found here)
            resultPaths[#resultPaths + 1] = k  -- Odd index for left.
            resultPaths[#resultPaths + 1] = ""
            local vModel, paths = v:lookup(resultPaths, ev)
            if vModel then
                return vModel, paths
            end
            -- Not found. revert the path back (Delete two array items that have been added above)
            resultPaths[#resultPaths] = nil
            resultPaths[#resultPaths] = nil
        --end
    end
    ngx.log(ngx.DEBUG, "END "..selfEName.."'s Left entities.")
    ngx.log(ngx.DEBUG, selfEName.."'s Right entities: ")
    vModels = self.rightTables
    for k, v in pairs(vModels) do
        --if k ~= resultPaths[#resultPaths - 1] then --> check last path from Left to avoid infinite loop
            -- Add path to this node (Assume that result will be found here)
            resultPaths[#resultPaths + 1] = ""
            resultPaths[#resultPaths + 1] = k  -- Even index for right.
            local vModel, paths = v:lookup(resultPaths, ev)
            if vModel then
                return vModel, paths
            end
            -- Not found. revert the path back (Delete two array items that have been added above)
            resultPaths[#resultPaths] = nil
            resultPaths[#resultPaths] = nil
        --end
    end
    ngx.log(ngx.DEBUG, "END "..selfEName.."'s Right entities. ")
    ngx.log(ngx.DEBUG, "END Entity: "..selfEName.."___________________________________")
    -- Not found any where in this node
    return nil, resultPaths
end
---
--- The paths params will be visit from tail
local function traverseBack(self, paths)
    if #path == 0 then
        return self
    end
    local vModel = nil
    local eName = paths[#paths]
    paths[#paths] = nil -- remove last item
    -- traversing backward hence even is LEFT, odd is RIGHT
    if eName == "" then -- even is empty.
        eName = paths[#paths] -- odd. even is empty ==> odd must not empty.
        vModel = self.rightTables[eName] -- odd is RIGHT
    else -- even not empty
        vModel = self.leftTables[eName] -- even is LEFT
    end
    paths[#paths] = nil -- remove second-last item
    assert(vModel ~= nil)
    return vModel:traverseBack(paths)
end
local function getRecord(selfInstance, key, conn)
    local record = selfInstance.keys[key]
    if not record and conn then
        return selfInstance:loadByKey(key, conn)
    end
    return record
end
local function loadByKey(selfInstance, key, conn)
    local ev = selfInstance.ed:get(key, conn)
    return selfInstance:addRecord(ev, conn)
end
local function filterPassed(record, filters)
    for j = 1, #filters, 1 do
        if not filters[i](ev) then
            return false
        end
    end
    return true
end
local function loadByFk(selfInstance, fKeyColumn, fKeyValue, conn)
    local group = selfInstance.groupBy[fKeyColumn][fKeyValue]
    if group then
        return group
    end
    local joinInfo = selfInstance.leftCols[fKeyColumn]
    if not joinInfo then
        local err = "Join relation is not declared: ".. fKeyColumn
        ngx.log(ngx.ERR, err)
        return nil, err
    end
    local filters = joinInfo
    local ev = ED[joinInfo.eName]:new({key = fKeyValue}, true)
    local keys = ev:getChildrenIds(selfInstance.ed.ename, conn)
    group = utils.newTable(#keys, 0)
    for i = 1, #keys, 1 do
        local record = selfInstance:getRecord(keys[i])
        if record then
            if not filterPassed(record, filters) then
                record = false
            end
        else
            local childEv = selfInstance.ed:get(key, conn)
            if filterPassed(record, filters) then
                record = selfInstance:addRecord(ev, conn)
            end
        end
        if record then
            group[#group + 1] = record
        end
    end
    selfInstance.groupBy[fKeyColumn][fKeyValue] = group
    return group
end

local function addRecord(selfInstance, ev, conn)
    -- unchecked: ev should be of type selfInstance.ed
    -- Apply filters
    if not filterPassed(ev, selfInstance.filters) then
        return nil
    end

    -- process Entity Values
    local values = ev.values
    local cols = selfInstance.columns
    local numCols = (cols and #cols) or 0
    local vRecord = setmetatable({}, {
        __index = function(tbl, key)
            local rightInfo = selfInstance.rightCols[key]
            if rightInfo then
                local vModel = selfInstance.rightTables[rightInfo[1]] --> rightInfo[1] is table name
                local groupBy = vModel.groupBy[rightInfo[2]] --> rightInfo[2] is joined column name
                return groupBy[vRecord.key]
            end
            return nil
        end})
    if numCols > 0 then
        for i = 1, numCols, 1 do
            vRecord[cols[i]] = values[cols[i]]
        end
        vRecord["key"] = values["key"]
        local ids = ev.ed.fnIds
        for i = 1, #ids, 1 do
            vRecord[ids[i]] = values[ids[i]]
        end
    else
        for k, v in pairs(values) do
            vRecord[k] = v
        end
    end

    selfInstance[#selfInstance + 1] = vRecord
    selfInstance.keys[vRecord.key] = vRecord

    -- process left joined columns:
    local leftCols = selfInstance.leftCols
    for k, v in pairs(leftCols) do
        local vModel = selfInstance.leftTables[v.eName]
        vRecord[k] = vModel.getRecord(vRecord[k], conn)
    end

    for k, _ in pairs(selfInstance.rightTables) do
        ngx.log(ngx.DEBUG, "Right table: "..k)
    end
    -- process right joined columns:
    local rightCols = selfInstance.rightCols
    for k, v in pairs(rightCols) do
        ngx.log(ngx.DEBUG, selfInstance.ed.ename.." right join to "..v[1]..", column "..v[2])
        local vModel = selfInstance.rightTables[v[1]] --> v[1] is table name
        vModel:loadByFk(v[2], vRecord.key, conn)
    end

    return record
end

local __instance = utils.newTable(0, 6)
__instance.lookup = lookup
__instance.traverseBack = traverseBack
__instance.getRecord = getRecord
__instance.addRecord = addRecord
__instance.loadByKey = loadByKey
__instance.loadByFk = loadByFk

local function newVModel(selfClass)
    local instance = setmetatable(utils.newTable(50, 10), {
        __index = __instance
    })
    instance.ed = selfClass.ed
    instance.columns = selfClass.columns
    instance.filters = selfClass.filters
    instance.leftCols = selfClass.leftCols
    instance.rightCols = selfClass.rightCols

    instance.keys = {}
    instance.groupBy = {}
    for k, _ in pairs(selfClass.leftCols) do
        instance.groupBy[k] = {}
    end

    instance.leftTables = setmetatable({}, {
        __index = function(_, key)
            if instance.parent and instance.posInParent == -1 -- right
                    and key == instance.parent.ed.ename then
                return instance.parent
            end
            return nil
        end
    })
    instance.rightTables = setmetatable(instance.leftTables, {
        __index = function(_, key)
            if instance.parent and instance.posInParent == 1 -- left
                    and key == instance.parent.ed.ename then
                return instance.parent
            end
            return nil
        end
    })
    for k, v in pairs(selfClass.leftTables) do
        ngx.log(ngx.DEBUG, "Copying Left tables: k = "..k..", v = "..v.ed.ename)
        addVModel(instance, v:newVModel(), 1)
    end
    for k, v in pairs(selfClass.rightTables) do
        ngx.log(ngx.DEBUG, "Copying Right tables: k = "..k..", v = "..v.ed.ename)
        addVModel(instance, v:newVModel(), -1)
    end
    for k, v in pairs(instance.leftTables) do
        ngx.log(ngx.DEBUG, "Instance Left tables: k = "..k..", v = "..v.ed.ename)
    end
    for k, v in pairs(instance.rightTables) do
        ngx.log(ngx.DEBUG, "Instance Right tables: k = "..k..", v = "..v.ed.ename)
    end

    return instance
end
local __vMClass = utils.newTable(0, 8)
__vMClass.addColumns = addColumns
__vMClass.addFilter = addFilter
__vMClass.leftJoin = leftJoin
__vMClass.rightJoin = rightJoin
__vMClass.lookup = lookup
__vMClass.newVModel = newVModel

eifo.VModelBuilder = {}
eifo.VModelBuilder.new = function(eName, ...)
    local class = {}
    class.ed = ED[eName]
    if not class.ed then
        return nil, "Unknown entity name "..eName
    end
    class.columns = {...}
    class.leftCols = {}
    class.rightCols = {}
    class.filters = {}
    class.leftTables = setmetatable({}, {__index =
        function(_, key)
            if class.parent and class.posInParent == -1  --right
                    and key == class.parent.ed.ename then
              return class.parent
            end
            return nil
        end
    })
    class.rightTables = setmetatable({}, {__index =
        function(_, key)
            if class.parent and class.posInParent == 1 --left
                    and key == class.parent.ed.ename then
               return class.parent
            end
            return nil
        end
    })
    return setmetatable(class, { __index = __vMClass })
end
return eifo.VModelBuilder