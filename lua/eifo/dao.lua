---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tnguyen.
--- DateTime: 9/17/23 1:18 PM
---

local KEY_SEP = "+"
local PREFIX_SEP = ":"

local utils = eifo.utils
local ngx = ngx
local ed
local _EV = {}
_EV.__index = {
    _notify = utils.observable._notify,
    resetKey = function(self, oldVals)
        if oldVals then
            local keyChanged = self:isKeyChanged(oldVals)
            if keyChanged >= 2 then
                self.values["key"] = nil -- Delete old key to re-generate
            end
        end

        if self.values["key"] then
            return self.values["key"]
        end

        local key, err = self.ed:generateKey(self.values)
        if not key then
            ngx.log(ngx.ERR, "Can not generate key for entity: "..(err or "No additional info"))
            return nil, err
        end
        self.values["key"] = key
        return self.values["key"]
    end,

    --- Replace foreign ID values by foreign key values
    resetFKeys = function(self, oldVals)
        if oldVals then
            local keyChanged = self:isKeyChanged(oldVals)
            if keyChanged == 0 or keyChanged == 2 then
                return -- No FK changes, do nothing
            end
        end
        local fkFields = self.ed.fnFKs
        for fnFK, edName in pairs(fkFields) do
            local fkId = self.values[fnFK]
            local fkEd = ed[edName]
            if fkId and string.sub(fkId, 1, fkEd.prefix:len()) ~= fkEd.prefix then
                local fKey = fkEd.prefix..PREFIX_SEP..fkId
                self.values[fnFK] = fKey
            end
        end
    end,
    --- Check if keys (foreign or primary) is changed
    --- Return 0 if no keys changed
    --- Return 1 if one of FKs changed
    --- Return 2 if PK changed and not any FK changed
    --- Return 3 if at least 1 PK AND 1 FK changed
    isKeyChanged = function(self, oldVals)
        local keyChanged = 0
        local fkFields = self.ed.fnFKs
        for k, _ in pairs(fkFields) do
            if oldVals[k] ~= nil then  -- fk changed
                keyChanged = 1
                break
            end
        end

        local idFields = self.ed.fnIds
        for i = #idFields, 1, -1 do
            if oldVals[idFields[i]] ~= nil then -- PK changed
                keyChanged = (keyChanged + 2)
                break
            end
        end
        return keyChanged
    end,
    getChildrenIds = function(self, entityName, fkColumnName, conn)
        local cEd = ed[entityName]
        local relKey = self:relKey(cEd, fkColumnName)
        return conn:sgetall(relKey)
    end,
    getChildren = function(self, entityName, fkColumnName, conn, childrenIds)
        local cEd = ed[entityName]
        childrenIds = childrenIds or self:getChildrenIds(entityName, fkColumnName, conn)
        local children = utils.newTable(#childrenIds, 0)
        for i = 1, #childrenIds, 1 do
            children[i] = cEd:new({key = childrenIds[i]})
            children[i].load(conn)
        end
        return children
    end,
    --- Load all fields from DB and overwrite existing fields of object
    --- Return a hash table containing all fields of this objects that is different to DB version
    load = function(self, conn)
        if self.ed.evs then
            return self.ed.evs[self.values.key]
        end
        local dbVals = conn:hgetall(self.values["key"]) or {}
        local _, hlen = utils.tbllen(dbVals)
        if hlen == 0 then
            return nil -- self is new, not found in DB
        end

        local memVals = self.values -- Keep the differences between memory vs vs DB version
        self.values = dbVals
        for k, v in pairs(memVals) do
            -- Remove all fields that have no differences
            if not self.values[k] or self.values[k] == v then
                memVals[k] = nil
            end
        end
        self:resetFKeys(memVals)
        return memVals
    end,
    removeOldParents = function(self, oldVals, conn)
        local parents = self.ed:getFKEntities(oldVals)
        if not parents or #parents == 0 then
            return 0
        end
        local count = 0
        for k, v in pairs(parents) do
            count = count + 1
            local relKey = v:relKey(self.ed, k)
            local num = conn:sremove(relKey, v.key)
            if not num then
                return nil, "Cannot remove foreign key "..v.key
            end
        end
        return count
    end,
    updateParents = function(self, oldVals, conn)
        local curFks = self.values
        if self.values.version > 1 then -- UPDATE
            local numFkChanges, err = self:removeOldParents(oldVals, conn)
            if not numFkChanges then
                return nil, err
            end
            if numFkChanges == 0 then
                return 0
            end
            curFks = utils.newTable(0, numFkChanges)
            local fnFks = self.ed.fnFKs
            for i = 1, #fnFks, 1 do
                if oldVals[fnFks[i]] ~= nil then
                    curFks[fnFks[i]] = self.values[fnFks[i]]
                end
            end
        end

        local fkEntities = self.ed:getFKEntities(curFks)
        if not fkEntities or utils.isTableEmpty(fkEntities) then
            return 0
        end
        local count = 0
        for k, v in pairs(fkEntities) do
            count = count + 1
            local relKey = v:relKey(self.ed, k)
            local num = conn:sadd(relKey, self.values.key)
    
            if not num then
                return nil, "Cannot add foreign key '"..self.values.key.."' into"..relKey
            end
        end
        return count
    end,
    relKey = function (self, childED, fkColumn)
        return childED.prefix..PREFIX_SEP..fkColumn..PREFIX_SEP..self.values["key"]
    end,
    _fail = function(conn, errMsg, nocommit)
        if not nocommit then
            conn:rollback()
        end
        return nil, errMsg
    end,
    save = function(self, conn, nocommit)
        if self.ed.evs then
            local errMsg = "Trying to update a read-only entity"
            error(errMsg, ngx.ERR)
            return nil, errMsg
        end
        ngx.log(ngx.DEBUG, "self.values['key'] = "..(self.values["key"] or "NIL")..". self.values.key = "..(self.values.key or "NIL"))
        local oldVals, err = conn:hset(self.values["key"], self.values)
        if not oldVals then return nil, "Failed to save: "..err end
        if utils.isTableEmpty(oldVals) and (not self.values["version"] or self.values["version"] > 1) then --case ignore update
            return {}
        end
        -- Index for FKs:
        local num, err = self:updateParents(oldVals, conn)
        if not num then
            return self._fail(conn, err, nocommit)
        end

        if not nocommit then
            conn:commit()
        end
        self:_notify(oldVals)
        return oldVals
    end,
    delete = function(self, conn, nocommit)
        if self.ed.evs then
            local errMsg = "Trying to update a read-only entity"
            error(errMsg, ngx.ERR)
            return nil, errMsg
        end
        local fields = utils.keys(self.values)
        if #fields == 0 then
            return nil, "Cannot delete: input hash table is empty"
        end
        return self:deleteFields(conn, fields, nocommit)
    end,
    deleteFields = function(self, conn, fields, nocommit)
        if self.ed.evs then
            local errMsg = "Trying to update a read-only entity"
            error(errMsg, ngx.ERR)
            return nil, errMsg
        end
        local oldVals, err, curVals = conn:hdel(self.values["key"], fields)
        if not oldVals then return nil, err end
        for k, _ in pairs(oldVals) do
            self.values[k] = nil
        end
        for k, v in pairs(curVals) do
            self.values[k] = v
        end
        if oldVals.key then
            conn:sremove(self.ed.prefix, oldVals.key)
        end
        self:resetFKeys(oldVals)
        self:resetKey(oldVals)
        self:removeOldParents(oldVals, conn)
        if not nocommit then
            conn:commit()
        end
        self:_notify(oldVals)
        return oldVals
    end
}
local _ED = {}
_ED.__index = {
    _attach = utils.observable._attach,
    _detach = utils.observable._detach,
    generateKey = function(self, id)
        local idType = type(id)
        if idType == "string" then
            return id
        end
        if idType == "table" then
            -- if the input data has a "key" field:
            if id.key then
                return id.key
            end

            -- else: generate key from IDs:
            local key, sep = self.prefix, PREFIX_SEP
            local idFields = self.fnIds
            -- if the input id is array:
            if #id > 0 then 
                if #id < #idFields then
                    return nil, "Number of given IDs is less than number of required IDs"
                end
                for i = 1, #idFields, 1 do
                    if not id[i] then
                        return nil, "ID field "..idFields[i].." is missing"
                    end

                    key = key..sep..string.gsub(id[i], PREFIX_SEP, ".")
                    sep = KEY_SEP
                end
                return key
            end

            -- else: is hash table (an EV):
            for i = 1, #idFields do
                local eId = id[idFields[i]]
                if not eId then
                    -- support another way to pass primary IDs:
                    eId = utils.popKey(id, "_id_"..i)
                end
                if not eId then
                    return nil, "ID field "..idFields[i].." is missing"
                end
                key = key..sep..string.gsub(eId, PREFIX_SEP, ".")
                sep = KEY_SEP
            end
            return key
        end
        return nil, "Unknown ID type"
    end,
    new = function(self, entityData, noReset)
        local ev = utils.newTable(0, 5)
        ev._observers = self._observers
        ev.ed = self
        if utils.isArray(entityData) then
            ngx.log(ngx.INFO, "EntityData = "..table.concat(entityData, ","))
            ev.values = utils.newTable(0, #entityData)
            local fnIds = self.fnIds
            local len = #fnIds
            if len > #entityData then
                return nil, "Entity Definition "..self.ename.." requires "..tostring(len).." IDs"
            end
            for i = 1, len, 1 do
                ev.values[fnIds[i]] = entityData[i]
            end
        else
            ev.values = entityData
        end
        if self.fnFKs["_idx"] then
            ev.values["_idx"] = "idx:index"
        end
        setmetatable(ev, _EV)
        if not noReset then
            -- Process foreign keys:
            ev:resetFKeys()
            -- Process primary key:
            local key, err = ev:resetKey()
            if not key then
                return nil, err
            end
            ngx.log(ngx.DEBUG, "ev.values['key'] = "..(ev.values["key"] or "NIL")..". ev.values.key = "..(ev.values.key or "NIL"))
        end
        return ev
    end,
    get = function(self, key, conn)
        key = self:generateKey(key)
        if self.evs then
            return self:new(self.evs[key])
        end
        local eData = conn:hgetall(key)
        if not eData or utils.isTableEmpty(eData) then
            return nil
        end
        eData["key"] = key
        return self:new(eData, true)
    end,
    getAll = function(self, conn)
        local ids = (self.evs and self.evs["all"]) or conn:sgetall(self.prefix)
        if not ids or #ids == 0 then
            return {}
        end
        local entities = utils.newTable(#ids, 0)
        for i = 1, #ids, 1 do
            entities[i] = self:get(ids[i], conn)
        end
        return entities
    end,
    getFKEntities = function(self, entityData)
        if not entityData or utils.isTableEmpty(entityData) then
            return {}
        end
        local fkFields = self.fnFKs
        local fKEntities = {}
        for fnFK, enFK in pairs(fkFields) do
            if entityData[fnFK] ~= nil then
                fKEntities[fnFK] = ed[enFK]:new({key = entityData[fnFK] })
            end
        end
        return fKEntities
    end,
}
ed = {
    _Index = setmetatable({
        ename = "_Index",
        prefix = "idx",
        fnIds = { "id" },
        fnFKs = {}
    }, _ED),
    -- _EnumType = setmetatable({
    --     ename = "_EnumType",
    --     prefix = "_et",
    --     fnIds = {"enumTypeId"}, --ID field names
    --     fnFKs = {} -- Foreign key field names
    -- }, _ED),
    _Enum = setmetatable({
        ename = "_Enum",
        prefix = "_e",
        fnIds = {"enumId"}, --ID field names
        fnFKs = {} -- {enumTypeId = "_EnumType"} -- Foreign key field names
    }, _ED),
    ProductCategory = setmetatable({
        ename = "ProductCategory",
        prefix = "pc",
        fnIds = {"productCategoryId"}, --ID field names
        fnFKs = {_idx = "_Index"} -- Foreign key field names
    }, _ED),
    Product = setmetatable({
        ename = "Product",
        prefix = "p",
        fnIds = { "productId" },
        fnFKs = {_idx = "_Index"}
    }, _ED),
    ProductContent = setmetatable({
        ename = "ProductContent",
        prefix = "pcnt",
        fnIds = {"productContentId"},
        fnFKs = {productId = "Product", productContentTypeEnumId="_Enum"}
    }, _ED),
    ProductAssoc = setmetatable({
        ename = "ProductAssoc",
        prefix = "pa",
        fnIds = {"productId", "toProductId", "productAssocTypeEnumId", "fromDate"},
        fnFKs = {productId = "Product", toProductId = "Product", productAssocTypeEnumId = "_Enum"}
    }, _ED),
    ProductFeature = setmetatable({
        ename = "ProductFeature",
        prefix = "pf",
        fnIds = {"productFeatureId"},
        fnFKs = {productFeatureTypeEnumId = "_Enum"}
    }, _ED),
    ProductFeatureAppl = setmetatable({
        ename = "ProductFeatureAppl",
        prefix = "pfa",
        fnIds = {"productId", "productFeatureId", "fromDate"},
        fnFKs = {applTypeEnumId = "_Enum", productId = "Product", productFeatureId = "ProductFeature"}
    }, _ED),
    ProductCategoryRollup = setmetatable({
        ename = "ProductCategoryRollup",
        prefix = "pcr",
        fnIds = {"productCategoryId", "parentProductCategoryId"},
        fnFKs = {productCategoryId = "ProductCategory", parentProductCategoryId = "ProductCategory"}
    }, _ED),
    ProductCategoryMember = setmetatable({
        ename = "ProductCategoryMember",
        prefix = "pcm",
        fnIds = {"productCategoryId", "productId", "fromDate"},
        fnFKs = {productCategoryId = "ProductCategory", productId = "Product"}
    }, _ED),
    ProductStore = setmetatable({
        ename = "ProductStore",
        prefix = "ps",
        fnIds = {"productStoreId"},
        fnFKs = {_idx = "_Index"}
    }, _ED),
    ProductStorePromotion = setmetatable({
        ename = "ProductStorePromotion",
        prefix = "psm",
        fnIds = {"storePromotionId"},
        fnFKs = {productStoreId = "ProductStore", _idx = "_Index"}
    }, _ED),
}
local idxEvs = utils.newTable(0, 2)
idxEvs["idx:index"] = {key = "idx:index", id = "index"}
idxEvs["all"] = {"idx:index"}
ed._Index.evs = idxEvs

local enumEvs = utils.newTable(0, 163)
local enumEvsArr = utils.newTable(28, 0)
enumEvs[#enumEvs+1] = {description="Accessory", enumId="PftAccessory", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Amount", enumId="PftAmount", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Net Weight", enumId="PftNetWeight", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Artist", enumId="PftArtist", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Billing", enumId="PftBilling", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Brand", enumId="PftBrand", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Care", enumId="PftCare", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Color", enumId="PftColor", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Dimension", enumId="PftDimension", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Equipment Class", enumId="PftEquipClass", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Fabric", enumId="PftFabric", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Genre", enumId="PftGenre", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Hardware", enumId="PftHardware", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="License", enumId="PftLicense", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Origin", enumId="PftOrigin", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Other", enumId="PftOther", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Packaging Component", enumId="PftPackagingComponent", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Packaging Type", enumId="PftPackagingType", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Product Quality", enumId="PftProdQuality", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Size", enumId="PftSize", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Software", enumId="PftSoftware", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Style", enumId="PftStyle", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Symptom", enumId="PftSymptom", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Topic", enumId="PftTopic", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Type", enumId="PftType", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Warranty", enumId="PftWarranty", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Model Year", enumId="PftModelYear", enumTypeId="ProductFeatureType"}
enumEvs[#enumEvs+1] = {description="Year Made", enumId="PftYearMade", enumTypeId="ProductFeatureType"}

enumEvs[#enumEvs+1] = {description="Asset (Good)", enumId="PtAsset", enumTypeId="ProductType"}
enumEvs[#enumEvs+1] = {description="Digital and Asset", enumId="PtDigitalAsset", enumTypeId="ProductType"}
enumEvs[#enumEvs+1] = {description="Digital (download)", enumId="PtDigital", enumTypeId="ProductType"}
enumEvs[#enumEvs+1] = {description="Asset Use", enumId="PtAssetUse", enumTypeId="ProductType"}
enumEvs[#enumEvs+1] = {description="Facility Use", enumId="PtFacilityUse", enumTypeId="ProductType"}
enumEvs[#enumEvs+1] = {description="Service", enumId="PtService", enumTypeId="ProductType"}
enumEvs[#enumEvs+1] = {description="Virtual (with variants)", enumId="PtVirtual", enumTypeId="ProductType"}
enumEvs[#enumEvs+1] = {description="Pick Assembly", enumId="PtPickAssembly", enumTypeId="ProductType"}
enumEvs[#enumEvs+1] = {description="Configurable Good", enumId="PtConfigurable", enumTypeId="ProductType"}

enumEvs[#enumEvs+1] = {description="Gift Card or Certificate", enumId="PclsGiftCard", enumTypeId="ProductClass"}

enumEvs[#enumEvs+1] = {description="Up-Sell (Upgrade)", enumId="PatUpsell", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Down-Sell (Downgrade)", enumId="PatDownSell", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="New Version, Replacement", enumId="PatReplacement", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Equivalent or Substitute", enumId="PatEquivalent", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Accessory", enumId="PatAccessory", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Add On For", enumId="PatAddOn", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Repair Service", enumId="PatRepairService", enumTypeId="ProductAssocType"}

enumEvs[#enumEvs+1] = {description="Cross-Sell (Complementary)", enumId="PatCrossSell", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Also Bought", enumId="PatAlsoBought", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Alternative Packaging", enumId="PatAlternativePkg", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Refurbished Equivalent", enumId="PatRefurbished", enumTypeId="ProductAssocType"}

enumEvs[#enumEvs+1] = {description="Product Variant", enumId="PatVariant", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Requires", enumId="PatRequires", enumTypeId="ProductAssocType"}

enumEvs[#enumEvs+1] = {description="Incompatible", enumId="PatIncompatible", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Unique Item", enumId="PatUniqueItem", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Auto Reorder (needs recurrenceInfoId)", enumId="PatAutoReorder", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Revision", enumId="PatRevision", enumTypeId="ProductAssocType"}

enumEvs[#enumEvs+1] = {description="Manufacturing Bill of Materials", parentEnumId="PatComponent", enumId="PatMfgBom", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Engineering Bill of Materials", parentEnumId="PatComponent", enumId="PatEngBom", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Product Manufactured As", enumId="PatMfgAs", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Used to Produce", enumId="PatUsedToProduce", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Configurable Product Instance", enumId="PatConfigInstance", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Actual Product Component", enumId="PatComponent", enumTypeId="ProductAssocType"}
enumEvs[#enumEvs+1] = {description="Packaging For", enumId="PatPackagingFor", enumTypeId="ProductAssocType"}

enumEvs[#enumEvs+1] = {description="Product Name", enumId="PcntProductName", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Description", enumId="PcntDescription", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Description - Long", enumId="PcntDescriptionLong", enumTypeId="ProductContentType"}

enumEvs[#enumEvs+1] = {description="Delivery Info", enumId="PcntDeliveryInfo", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Digital Download", enumId="PcntDownload", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Directions", enumId="PcntDirections", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Fulfillment Email", enumId="PcntEmail", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Frequently Asked Questions", enumId="PcntFAQ", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Ingredients", enumId="PcntIngredients", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Ingredients - Unique", enumId="PcntUniqueIngred", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Installation", enumId="PcntInstallation", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Label Image", enumId="PcntLabelImage", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Label Text", enumId="PcntLabelText", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Online Access", enumId="PcntOnline", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Price Detail Text", enumId="PcntPriceDetail", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Short Sales Pitch", enumId="PcntShortSalesPitch", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Special Instructions", enumId="PcntSpecialInstr", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Specification", enumId="PcntSpecification", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Terms and Conditions", enumId="PcntTermsConditions", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Testimonials", enumId="PcntTestimonials", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Warnings", enumId="PcntWarnings", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Warranty", enumId="PcntWarranty", enumTypeId="ProductContentType"}

enumEvs[#enumEvs+1] = {description="Image - Small", enumId="PcntImageSmall", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Image - Medium", enumId="PcntImageMedium", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Image - Large", enumId="PcntImageLarge", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Image - Detail", enumId="PcntImageDetail", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Image - Original", enumId="PcntImageOriginal", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Image URL - Small", enumId="PcntImageUrlSmall", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Image URL - Medium", enumId="PcntImageUrlMedium", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Image URL - Large", enumId="PcntImageUrlLarge", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Image URL - Detail", enumId="PcntImageUrlDetail", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Image URL - Original", enumId="PcntImageUrlOriginal", enumTypeId="ProductContentType"}

enumEvs[#enumEvs+1] = {description="Add To Cart Label", enumId="PcntAddToCartLabel", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Add To Cart Image", enumId="PcntAddToCartImage", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Meta-Keywords", enumId="PcntMetaKeywords", enumTypeId="ProductContentType"}
enumEvs[#enumEvs+1] = {description="Meta-Description", enumId="PcntMetaDescription", enumTypeId="ProductContentType"}

enumEvs[#enumEvs+1] = {description="Sales Required Info", enumId="PfmtSalesRequired", enumTypeId="ProductFormType"}
enumEvs[#enumEvs+1] = {description="Sales Optional Info", enumId="PfmtSalesOptional", enumTypeId="ProductFormType"}
enumEvs[#enumEvs+1] = {description="Post Sale Survey", enumId="PfmtPostSaleSurvey", enumTypeId="ProductFormType"}

enumEvs[#enumEvs+1] = {description="Purchase Include", enumId="PgpPurchaseInclude", enumTypeId="ProductGeoPurpose"}
enumEvs[#enumEvs+1] = {description="Purchase Exclude", enumId="PgpPurchaseExclude", enumTypeId="ProductGeoPurpose"}
enumEvs[#enumEvs+1] = {description="Shipment Include", enumId="PgpShipmentInclude", enumTypeId="ProductGeoPurpose"}
enumEvs[#enumEvs+1] = {description="Shipment Exclude", enumId="PgpShipmentExclude", enumTypeId="ProductGeoPurpose"}

enumEvs[#enumEvs+1] = {description="ISBN", enumId="PidtIsbn", enumTypeId="ProductIdentificationType"}
enumEvs[#enumEvs+1] = {description="Mfg Model Number", enumId="PidtMfgModelNum", enumTypeId="ProductIdentificationType"}
enumEvs[#enumEvs+1] = {description="Other", enumId="PidtOther", enumTypeId="ProductIdentificationType"}
enumEvs[#enumEvs+1] = {description="SKU", enumId="PidtSku", enumTypeId="ProductIdentificationType"}
enumEvs[#enumEvs+1] = {description="UPC-A", enumId="PidtUpca", enumTypeId="ProductIdentificationType"}
enumEvs[#enumEvs+1] = {description="UPC-E", enumId="PidtUpce", enumTypeId="ProductIdentificationType"}
enumEvs[#enumEvs+1] = {description="EAN", enumId="PidtEan", enumTypeId="ProductIdentificationType"}
enumEvs[#enumEvs+1] = {description="GTIN", enumId="PidtGtin", enumTypeId="ProductIdentificationType"}
enumEvs[#enumEvs+1] = {description="Library of Congress", enumId="PidtLoc", enumTypeId="ProductIdentificationType"}
enumEvs[#enumEvs+1] = {description="URL Slug", enumId="PidtUrlSlug", enumTypeId="ProductIdentificationType"}
enumEvs[#enumEvs+1] = {description="HTS (Tariff)", enumId="PidtHts", enumTypeId="ProductIdentificationType"}

enumEvs[#enumEvs+1] = {description="List Price", enumId="PptList", enumTypeId="ProductPriceType"}
enumEvs[#enumEvs+1] = {description="Current Price", enumId="PptCurrent", enumTypeId="ProductPriceType"}
enumEvs[#enumEvs+1] = {description="Average Cost", enumId="PptAverage", enumTypeId="ProductPriceType"}
enumEvs[#enumEvs+1] = {description="Minimum Price", enumId="PptMinimum", enumTypeId="ProductPriceType"}
enumEvs[#enumEvs+1] = {description="Maximum Price", enumId="PptMaximum", enumTypeId="ProductPriceType"}
enumEvs[#enumEvs+1] = {description="Promotional Price", enumId="PptPromotional", enumTypeId="ProductPriceType"}
enumEvs[#enumEvs+1] = {description="Competitive Price", enumId="PptCompetitive", enumTypeId="ProductPriceType"}
enumEvs[#enumEvs+1] = {description="Wholesale Price", enumId="PptWholesale", enumTypeId="ProductPriceType"}
enumEvs[#enumEvs+1] = {description="Special Promo Price", enumId="PptSpecialPromo", enumTypeId="ProductPriceType"}

enumEvs[#enumEvs+1] = {description="Purchase/Initial", enumId="PppPurchase", enumTypeId="ProductPricePurpose"}
enumEvs[#enumEvs+1] = {description="Recurring Charge", enumId="PppRecurring", enumTypeId="ProductPricePurpose"}
enumEvs[#enumEvs+1] = {description="Usage Charge", enumId="PppUsage", enumTypeId="ProductPricePurpose"}
enumEvs[#enumEvs+1] = {description="Component Price", enumId="PppComponent", enumTypeId="ProductPricePurpose"}

enumEvs[#enumEvs+1] = {enumId="SpoMain", sequenceNum="1", description="Main Supplier", enumTypeId="SupplierPreferredOrder"}
enumEvs[#enumEvs+1] = {enumId="SpoAlternate", sequenceNum="2", description="Alternate Supplier", enumTypeId="SupplierPreferredOrder"}

enumEvs[#enumEvs+1] = {description="Product Price Modify", enumId="ProductPriceModify", enumTypeId="ServiceRegisterType"}

enumEvs[#enumEvs+1] = {description="Catalog", enumId="PctCatalog", enumTypeId="ProductCategoryType"}
enumEvs[#enumEvs+1] = {description="Industry", enumId="PctIndustry", enumTypeId="ProductCategoryType"}
enumEvs[#enumEvs+1] = {description="Internal", enumId="PctInternal", enumTypeId="ProductCategoryType"}
enumEvs[#enumEvs+1] = {description="Materials", enumId="PctMaterials", enumTypeId="ProductCategoryType"}
enumEvs[#enumEvs+1] = {description="Quick Add", enumId="PctQuickAdd", enumTypeId="ProductCategoryType"}
enumEvs[#enumEvs+1] = {description="Search", enumId="PctSearch", enumTypeId="ProductCategoryType"}
enumEvs[#enumEvs+1] = {description="Usage", enumId="PctUsage", enumTypeId="ProductCategoryType"}
enumEvs[#enumEvs+1] = {description="Mix and Match", enumId="PctMixMatch", enumTypeId="ProductCategoryType"}
enumEvs[#enumEvs+1] = {description="Cross Sell", enumId="PctCrossSell", enumTypeId="ProductCategoryType"}
enumEvs[#enumEvs+1] = {description="Tax", enumId="PctTax", enumTypeId="ProductCategoryType"}
enumEvs[#enumEvs+1] = {description="Gift Card", enumId="PctGiftCard", enumTypeId="ProductCategoryType"}
enumEvs[#enumEvs+1] = {description="Best Selling", enumId="PctBestSelling", enumTypeId="ProductCategoryType"}
enumEvs[#enumEvs+1] = {description="Inventory Group", enumId="PctInventoryGroup", enumTypeId="ProductCategoryType"}

enumEvs[#enumEvs+1] = {description="Category Name", enumId="PcctCategoryName", enumTypeId="ProductCategoryContentType"}
enumEvs[#enumEvs+1] = {description="Description", enumId="PcctDescription", enumTypeId="ProductCategoryContentType"}
enumEvs[#enumEvs+1] = {description="Description - Long", enumId="PcctDescriptionLong", enumTypeId="ProductCategoryContentType"}
enumEvs[#enumEvs+1] = {description="Category Image URL", enumId="PcctImageUrl", enumTypeId="ProductCategoryContentType"}
enumEvs[#enumEvs+1] = {description="Category Image Alt Text", enumId="PcctImageAltText", enumTypeId="ProductCategoryContentType"}
enumEvs[#enumEvs+1] = {description="Footer", enumId="PcctFooter", enumTypeId="ProductCategoryContentType"}
enumEvs[#enumEvs+1] = {description="Meta-Keywords", enumId="PcctMetaKeywords", enumTypeId="ProductCategoryContentType"}
enumEvs[#enumEvs+1] = {description="Meta-Description", enumId="PcctMetaDescription", enumTypeId="ProductCategoryContentType"}

enumEvs[#enumEvs+1] = {description="URL Slug", enumId="PcitUrlSlug", enumTypeId="ProductCategoryIdentType"}

enumEvs[#enumEvs+1] = {description="Standard", enumId="PfatStandard", enumTypeId="ProductFeatureApplType"}
enumEvs[#enumEvs+1] = {description="Selectable", enumId="PfatSelectable", enumTypeId="ProductFeatureApplType"}
enumEvs[#enumEvs+1] = {description="Distinguishing", enumId="PfatDistinguishing", enumTypeId="ProductFeatureApplType"}
enumEvs[#enumEvs+1] = {description="Optional", enumId="PfatOptional", enumTypeId="ProductFeatureApplType"}

enumEvs[#enumEvs+1] = {description="Dependency", enumId="PfitDependency", enumTypeId="ProductFeatureIactnType"}
enumEvs[#enumEvs+1] = {description="Compatible", enumId="PfitCompatible", enumTypeId="ProductFeatureIactnType"}
enumEvs[#enumEvs+1] = {description="Incompatible", enumId="PfitIncompatible", enumTypeId="ProductFeatureIactnType"}
enumEvs[#enumEvs+1] = {description="Composition", enumId="PfitComposition", enumTypeId="ProductFeatureIactnType"}

enumEvs[#enumEvs+1] = {description="Product", enumId="StProduct", enumTypeId="SubscriptionType"}

local allKeys = utils.newTable(28, 0)
for i = #enumEvsArr, 1, -1 do
    local ev = enumEvsArr[i]
    local evKey = "_e:"..ev.enumId
    enumEvs[evKey] = ev
    allKeys[#allKeys+1] = evKey
end
enumEvs["all"] = allKeys
ed._Enum.evs = enumEvs
return ed
