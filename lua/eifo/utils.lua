---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tnguyen.
--- DateTime: 9/14/23 5:00 PM
---
ngx.log(ngx.INFO, "Initilizing utils...")
local newTable, newArray, newHashTbl
if table["new"] then
    newTable = table["new"]
    newArray = function (size)
        return table["new"](size, 0)
    end
    newHashTbl = function (size)
        return table["new"](0, size)
    end
else
    newTable = function (...) return {} end
    newArray = newTable
    newHashTbl = newTable
end
local isTableEmpty = function(tbl)
    return not tbl or next(tbl) == nil
end
local isArray = function(tbl)
    return not tbl or (type(tbl) == 'table' and (#tbl > 0 or next(tbl) == nil))
end
local isHashTbl = function(tbl)
    return not tbl or type(tbl) == 'table' and #tbl == 0
end
local tbllen = function(tbl)
    if not tbl then
        return 0, 0
    end
    local len = 0
    local k = next(tbl)
    while k ~= nil do
        k = next(tbl, k)
        len = len + 1
    end
    local arrlen = #tbl
    return arrlen, len - arrlen
end
local function sourceCode(f)
    local t = debug.getinfo(f)
    return t.source
    --if t.linedefined < 0 then return t.source end
    --local i = 0
    --local text = {}
    --local name = t.source:gsub("^@","")
    --if not name then
    --    return t.source
    --end
    --for line in io.lines(name) do
    --    i=i+1
    --    if i >= t.linedefined then text[#text+1] = line end
    --    if i >= t.lastlinedefined then break end
    --end
    --return table.concat(text,"\n")
end
local function toJson(v, refs)
    if v == nil then return "null" end
    local vType = type(v)
    if vType ~= "table" then
        return (vType == "string" and ('"'..v..'"'))
                or (vType == "boolean" and (v and "true" or "false"))
                or (vType == "function" and sourceCode(v))
                or _G.tostring(v)
    end
                    
    -- prevent circular invokes:
    if not refs or #refs == 0 then
        refs = {v}
    else
        local refsLen = #refs
        for i = 1, refsLen, 1 do
            if v == refs[i] then
                return v.key and '{key = "'..v.key..'"}' or "null"
            end
        end
        refs[refsLen + 1] = v
    end
    local kvSep = ":"
    local str
    if vType == "table" then
        if #v > 0 then
            str = "["
            str = str..toJson(v[1], refs)
            for i = 2, #v, 1 do
                str = str..", "..toJson(v[i], refs)
            end
            str = str.."]"
        else
            str = "{ "
            for key, val in pairs(v) do
                str = str..'"'..key..'"'..kvSep..toJson(val, refs)..","
            end
            str = str:sub(1, -2).."}"
        end
    end
    refs[#refs] = nil
    return  str or "null"
end

local function toString(v, kvSep, newLine, refs)
    if v == nil then return "nil" end
    if not v then return "false" end
    local vType = type(v)
    local strTab = "\r"
    -- prevent circular invokes:
    if not refs or #refs == 0 then
        refs = {v}
    else
        local refsLen = #refs
        for i = 1, refsLen, 1 do
            strTab = strTab.."    "
            if v == refs[i] then
                return vType
            end
        end
        refs[refsLen + 1] = v
    end
    local str
    if vType == "table" then
        kvSep = kvSep or ":"
        newLine = newLine or "<br>"
        str = strTab.."{"
        if #v > 0 then
            str = str..strTab.."    "..toString(v[1], kvSep, newLine, refs)
            for i = 2, #v, 1 do
                str = str..", "..strTab.."    "..toString(v[i], kvSep, newLine, refs)
            end
        else
            for key, val in pairs(v) do
                str = str..strTab.."    "..key..kvSep..toString(val, kvSep, newLine, refs)
            end
        end
        str = strTab..str.."}"
    end
    refs[#refs] = nil
    return  str
            or (vType == "string" and v)
            or (vType == "number" and _G.tostring(v))
            or (vType == "boolean" and "true")
            or (vType == "function" and sourceCode(v))
            or vType
end

local function timeFromDbStr(dbDateTimeStr)
    ngx.log(ngx.DEBUG, dbDateTimeStr)
    local pattern = "(%d+)-(%d+)-(%d+) (%d+):(%d+):?(%d*)"
    local year, month, day, hour, minute, second = dbDateTimeStr:match(pattern)
    local dateObj = {year = year, month = month, day = day, hour = hour, minute = minute, second = second}
    ngx.log(ngx.DEBUG, toJson(dateObj))
    return os.time(dateObj)
end

local attach = function(self, observer)
    if not observer._observerId then
        local errMsg = [[Observer have no observerId]]
        ngx.log(ngx.ERR, errMsg)
        return nil, errMsg
    end
    if not observer._update then
        local errMsg = [[Observer doesn't have a function named '_update(self, entityValue, oldValHashmap)']]
        ngx.log(ngx.ERR, errMsg)
        return nil, "Observer have no _update method"
    end
    if not self._observers then
        self._observers = {}
    end
    self._observers[observer._observerId] = observer
    return self
end
local detach = function(self, observerId)
    if not observerId then
        return nil, "observerId is required"
    end
    self._observers[observerId] = nil
    return self
end
local notify = function(self, oldVals, newVals)
    if not self._observers or isTableEmpty(self._observers) then
        -- ngx.log(ngx.ALERT, "Notify without any receivers: "..toString(self, ": ", "\r\n"))
        return false, "No receivers"
    end
    ngx.log(ngx.DEBUG, "Sender: "..toString(self, ": ", "\r\n"))
    ngx.log(ngx.DEBUG, "oldVals: "..toString(oldVals, ": ", "\r\n"))

    for _, v in pairs(self._observers) do
        ngx.log(ngx.DEBUG, "Receiver: "..toString(v, ": ", "\r\n"))
        v:_update(self, oldVals, newVals)
    end
    return true
end

local _lifo = {}
_lifo.__index = {
    pop = function(self)
        local values = self.values
        local len = #values
        local item = values[len]
        values[len] = nil
        return item
    end,
    push = function(self, item)
        local values = self.values
        local newlen = #values + 1
        values[newlen] = item
        return newlen
    end,
    reset = function(self) self.values = {}  end,
    len = function(self) return #self.values   end
}
local lifo = function(initialValues)
    if not isArray(initialValues) then
        return nil, "input table must be an array"
    end

    initialValues = initialValues or {}
    return setmetatable({values = initialValues}, _lifo)
end
local existIn = function(array, item, from, to)
    local i = from or #array
    if i < 0 then return 0 end
    if not to then
        if i <= 1 then
            to = #array
        else
            to = 1
        end
    end
    local step, inRange
    if i < to then
        step = 1
        inRange = function(a, b) return a <= b end
    else
        step = -1
        inRange = function(a, b) return a >= b end
    end

    local notFound = true
    while (inRange(i, to) and notFound) do
        notFound = (array[i] == item)
        i = i + step
    end
    if notFound then return 0 end
    return i
end
local keys = function(tbl)
    local _, hlen = tbllen(tbl)
    local keys = newTable(0, hlen)
    local i=0
    for k,_ in pairs(tbl) do
        i=i+1
        keys[i]=k
    end
    return keys
end
---check existence by using 'key' property
---@param array any
---@param record any
---@return number index of existing array item, or new array length
local addIfNotExist = function(array, record)
    local idx, len = 1, #array
    while idx <= len do
        if array[idx] == record or array[idx].key == record.key then
            return idx
        end
        idx = idx + 1
    end
    array[idx] = record
    return idx
end
local responseError = function(httpStatus, errMessage)
    ngx.status = httpStatus
    ngx.say("{'message':'"..errMessage.."'}")
    --ngx.eof()
end
local popKey = function(tbl, key)
    local val = tbl[key]
    tbl[key] = nil
    return val
end
local mergeRef = function(lTable, rTable)
    if not lTable then
        return rTable
    end
    if not rTable then
        return lTable
    end
    for k,v in pairs(rTable) do
        lTable[k] = v
    end
    return lTable
end
local listToHash = function(list)
    if not list or #list == 0 then
        return list --unchanged
    end

    local hashmap = {}
    for i = 1, #list - 1, 2 do
        hashmap[list[i]] = list[i + 1]
    end
    return hashmap
end

local removeItem = function(list, item)
    local n = #list
    local found = {}
    local i = 1
    for j = 1, n, 1 do
        if list[j] == item then
            -- pop and not increase i :
            found[#found + 1] = list[j]
            list[j] = nil
        elseif list[j] == nil then
            -- continue next loop without increasing i
        else
            if j > i then
                list[i] = list[j]
                list[j] = nil
            end
            i = i + 1
        end
    end
    return found
end
local splitStr = function(str, separator)
    local tokens = {}
    local sepRegex = "([^"..separator.."]+)"
    for token in str:gmatch(sepRegex) do
        tokens[#tokens + 1] = token
    end
    return tokens
end
local getPropertyValue = function (obj, propPath)
    local propPaths = splitStr(propPath, "%.")
    local numPaths = #propPaths
    local i = 1
    local objProp = obj[propPaths[i]]
    while objProp ~= nil and i <= numPaths do
        i = i + 1
        objProp = objProp[propPaths[i]]
    end
    return objProp
end

local getPathParam = function(uri, api)
    local paramStr = uri
    if api then
        local _, e = uri:find(api)
        local i = uri:find('?')
        if not i then
            i = uri:find(' ')
        end
        if not i then
            i = uri:len() + 1
        end
        paramStr = uri:sub(e+1, i-1)
    end
    return splitStr(paramStr, "/")
end
local utils = newTable(0, 27)
utils.sourceCode = sourceCode
utils.splitStr = splitStr
utils.getPropertyValue = getPropertyValue
utils.getPathParam = getPathParam
utils.newTable = newTable
utils.newArray = newArray
utils.newHashTbl = newHashTbl
utils.isArray = isArray
utils.existIn = existIn
utils.isHashTbl = isHashTbl
utils.isTableEmpty = isTableEmpty
utils.keys = keys
utils.popKey = popKey
utils.removeItem = removeItem
utils.mergeRef = mergeRef
utils.listToHash = listToHash
utils.tbllen = tbllen
utils.toString = toString
utils.toJson = toJson
utils.addIfNotExist = addIfNotExist
utils.timeFromDbStr = timeFromDbStr
utils.printTable = function(tbl)
    if not tbl then
        ngx.say("Table is null")
        return
    end
    for k,v in pairs(tbl) do
        ngx.say (k..": "..utils.toString(v).."<br/>")
    end
end
utils.getHashedString = function (str, len)
    local bytes = {string.byte(str, 1, -1)}
    local h = 0
    for i = 1, #bytes, 1 do
        local bits = tonumber(bytes[i])
        h = bit.band(h*31 + bits, 0x7fffffff)
    end
    return string.format("%0"..len.."x", h)
end

utils.lifo = lifo

utils.responseError = responseError

utils.cloneHashTbl = function(hTable, resultTable, refs)
    for key, value in pairs(hTable) do
        resultTable[key] = utils.clone(value, refs)
    end
end
utils.cloneArray = function(arr, resultArray, refs)
    local len = #arr
    local newTbl = {}
    for i = 1, len, 1 do
        resultArray[i] = utils.clone(arr[i], refs)
    end
    return newTbl
end
utils.clone = function(v, refs)
    if not v or type(v) ~= "table" then
        return v
    end

    local newTbl = {}
    -- prevent circular invokes:
    if not refs or #refs == 0 then
        refs = {v}
    else
        for i = #refs, 1, -1 do
            if v == refs[i] then
                return v
            end
        end
        refs[#refs + 1] = v
    end
    if #v > 0 then
        newTbl = utils.cloneArray(v, refs)
    end
    utils.cloneHashTbl(v, newTbl, refs)
    setmetatable(newTbl, getmetatable(v))
    refs[#refs] = nil
    return newTbl
end
utils.ArraySet = {_fnKey = "key"}
function utils.ArraySet:add(record)
    local key = record[self._fnKey] or record
    local idx = self.__keys[key]
    if idx then
        return idx
    end
    idx = #self + 1
    self[idx] = record
    self.__keys[key] = idx
    return idx
end

function utils.ArraySet:index(itemOrKey)
    local itemKey = itemOrKey[self._fnKey] or itemOrKey
    return self.__keys[itemKey]
end
function utils.ArraySet:keys(itemOrKey)
    --ngx.log(ngx.DEBUG, "ArrraySet:keys "..utils.toString(itemOrKey))
    local itemKey = itemOrKey[self._fnKey] or itemOrKey
    local idx = self.__keys[itemKey]
    return idx and self[idx] or nil
end

function utils.ArraySet:remove(itemOrKey) 
    local itemKey = itemOrKey[self._fnKey] or itemOrKey
    local idx  = self.__keys[itemKey]
    if(not idx) then return nil end
    for i = idx, #self - 1, 1 do
        self[i] = self[i+1]
    end
    self[#self] = nil
    self.__keys[itemKey] = nil
    return idx
end
function utils.ArraySet:intersect(otherSet)
    if not otherSet then
        return self
    end
    local arraySet = getmetatable(self):new()
    for i = 1, #otherSet, 1 do
        if self:index(otherSet[i]) then
            arraySet:add(otherSet[i])
        end
    end
    return arraySet
end

function utils.ArraySet:new(array, nameOfKeyField)
    local arraySet = array or {}
    if nameOfKeyField then
        arraySet._fnKey = nameOfKeyField
    end
    arraySet.__keys = {}
    for i = 1, #arraySet, 1 do
        local key = arraySet[i][nameOfKeyField] or arraySet[i]
        arraySet.__keys[key] = i
    end
    setmetatable(arraySet, self)
    self.__index = self
    return arraySet
end

utils.observable = {
    _attach = attach,
    _detach = detach,
    _notify = notify
}

return utils