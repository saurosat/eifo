---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tnguyen.
--- DateTime: 9/14/23 5:00 PM
---
if not eifo then
    eifo = {}
end
if eifo.utils then
    return eifo.utils
end

local newTable
do
    local ok
    ok, newTable = pcall(require, "table.new")
    if not ok then newTable = function(...) return {} end end
end

local attach = function(self, observer)
    if not observer._observerId then
        local errMsg = [[Observer have no observerId]]
        ngx.log(ngx.ERR, errMsg)
        return nil, errMsg
    end
    if not observer._update then
        local errMsg = [[Observer doesn't have a function named '_update(self, entityValue, oldValHashmap)']]
        ngx.log(ngx.ERR, errMsg)
        return nil, "Observer have no _update method"
    end
    if not self._observers then
        self._observers = {}
    end
    self._observers[observer._observerId] = observer
    return self
end
local detach = function(self, observerId)
    if not observerId then
        return nil, "observerId is required"
    end
    self._observers[observerId] = nil
    return self
end
local notify = function(self, oldVals)
    ngx.log(ngx.DEBUG, "Sender: "..eifo.utils.toString(self, ": ", "\r\n"))
    ngx.log(ngx.DEBUG, "oldVals: "..eifo.utils.toString(oldVals, ": ", "\r\n"))

    if not self._observers or eifo.utils.isTableEmpty(self._observers) then
        ngx.log(ngx.ALERT, "Notify without any receivers: "..eifo.utils.toString(self, ": ", "\r\n"))
        return false, "No receivers"
    end
    for _, v in pairs(self._observers) do
        ngx.log(ngx.DEBUG, "Receiver: "..eifo.utils.toString(v, ": ", "\r\n"))
        v:_update(self, oldVals)
    end
    return true
end

local _lifo = {}
_lifo.__index = {
    pop = function(self)
        local values = self.values
        local len = #values
        local item = values[len]
        values[len] = nil
        return item
    end,
    push = function(self, item)
        local values = self.values
        local newlen = #values + 1
        values[newlen] = item
        return newlen
    end,
    reset = function(self) self.values = {}  end,
    len = function(self) return #self.values   end
}
local lifo = function(initialValues)
    if not eifo.utils.isArray(initialValues) then
        return nil, "input table must be an array"
    end

    initialValues = initialValues or {}
    return setmetatable({values = initialValues}, _lifo)
end
local isTableEmpty = function(tbl)
    return not tbl or next(tbl) == nil
end
local isArray = function(tbl)
    return not tbl or (type(tbl) == 'table' and (#tbl > 0 or next(tbl) == nil))
end
local isHashTbl = function(tbl)
    return not tbl or type(tbl) == 'table' and #tbl == 0
end
local tbllen = function(tbl)
    if not tbl then
        return 0, 0
    end
    local len = 0
    local k = next(tbl)
    while k ~= nil do
        k = next(tbl, k)
        len = len + 1
    end
    local arrlen = #tbl
    return arrlen, len - arrlen
end
local existIn = function(array, item, from, to)
    local i = from or #array
    if i < 0 then return 0 end
    if not to then
        if i <= 1 then
            to = #array
        else
            to = 1
        end
    end
    local step, inRange
    if i < to then
        step = 1
        inRange = function(a, b) return a <= b end
    else
        step = -1
        inRange = function(a, b) return a >= b end
    end

    local notFound = true
    while (inRange(i, to) and notFound) do
        notFound = (array[i] == item)
        i = i + step
    end
    if notFound then return 0 end
    return i
end
local keys = function(tbl)
    local _, hlen = eifo.utils.tbllen(tbl)
    local keys = eifo.utils.newTable(0, hlen)
    local i=0
    for k,_ in pairs(tbl) do
        i=i+1
        keys[i]=k
    end
    return keys
end


local responseError = function(httpStatus, errMessage)
    ngx.status = httpStatus
    ngx.say("{'message':'"..errMessage.."'}")
    ngx.eof()
end
local popKey = function(tbl, key)
    local val = tbl[key]
    tbl[key] = nil
    return val
end
local mergeRef = function(lTable, rTable)
    if not lTable then
        return rTable
    end
    if not rTable then
        return lTable
    end
    for k,v in pairs(rTable) do
        lTable[k] = v
    end
    return lTable
end
local listToHash = function(list)
    if not list or #list == 0 then
        return list --unchanged
    end

    local hashmap = {}
    for i = 1, #list - 1, 2 do
        hashmap[list[i]] = list[i + 1]
    end
    return hashmap
end

local removeItem = function(list, item)
    local n = #list
    local found = {}
    local i = 1
    for j = 1, n, 1 do
        if list[j] == item then
            -- pop and not increase i :
            found[#found + 1] = list[j]
            list[j] = nil
        elseif list[j] == nil then
            -- continue next loop without increasing i
        else
            if j > i then
                list[i] = list[j]
                list[j] = nil
            end
            i = i + 1
        end
    end
    return found
end
local splitStr = function(str, separator)
    local tokens = {}
    local sepRegex = "([^"..separator.."]+)"
    for token in str:gmatch(sepRegex) do
        tokens[#tokens + 1] = token
    end
    return tokens
end

local getPathParam = function(uri, api)
    local paramStr = uri
    if api then
        local _, e = uri:find(api)
        local i = uri:find('?')
        if not i then
            i = uri:find(' ')
        end
        if not i then
            i = uri:len() + 1
        end
        paramStr = uri:sub(e+1, i-1)
    end
    return splitStr(paramStr, "/")
end
local function sourceCode(f)
    local t = debug.getinfo(f)
    return t.source
    --if t.linedefined < 0 then return t.source end
    --local i = 0
    --local text = {}
    --local name = t.source:gsub("^@","")
    --if not name then
    --    return t.source
    --end
    --for line in io.lines(name) do
    --    i=i+1
    --    if i >= t.linedefined then text[#text+1] = line end
    --    if i >= t.lastlinedefined then break end
    --end
    --return table.concat(text,"\n")
end
local function toString(v, kvSep, newLine, refs)
    if v == nil then return "nil" end
    if not v then return "false" end
    local vType = type(v)
    local strTab = "\r"
    -- prevent circular invokes:
    if not refs or #refs == 0 then
        refs = {v}
    else
        local refsLen = #refs
        for i = 1, refsLen, 1 do
            strTab = strTab.."    "
            if v == refs[i] then
                return vType
            end
        end
        refs[refsLen + 1] = v
    end
    local str
    if vType == "table" then
        kvSep = kvSep or ":"
        newLine = newLine or "<br>"
        str = strTab.."{"
        if #v > 0 then
            str = str..strTab.."    "..toString(v[1], kvSep, newLine, refs)
            for i = 2, #v, 1 do
                str = str..", "..strTab.."    "..toString(v[i], kvSep, newLine, refs)
            end
        else
            for key, val in pairs(v) do
                str = str..strTab.."    "..key..kvSep..toString(val, kvSep, newLine, refs)
            end
        end
        str = strTab..str.."}"
    end
    refs[#refs] = nil
    return  str
            or (vType == "string" and v)
            or (vType == "number" and _G.tostring(v))
            or (vType == "boolean" and "true")
            or (vType == "function" and sourceCode(v))
            or vType
end
eifo.utils = newTable(0, 20)
eifo.utils.sourceCode = sourceCode
eifo.utils.splitStr = splitStr
eifo.utils.getPathParam = getPathParam
eifo.utils.newTable = newTable
eifo.utils.isArray = isArray
eifo.utils.existIn = existIn
eifo.utils.isHashTbl = isHashTbl
eifo.utils.isTableEmpty = isTableEmpty
eifo.utils.keys = keys
eifo.utils.popKey = popKey
eifo.utils.removeItem = removeItem
eifo.utils.mergeRef = mergeRef
eifo.utils.listToHash = listToHash
eifo.utils.tbllen = tbllen
eifo.utils.toString = toString
eifo.utils.printTable = function(tbl)
    if not tbl then
        ngx.say("Table is null")
        return
    end
    for k,v in pairs(tbl) do
        ngx.say (k..": "..eifo.utils.toString(v).."<br/>")
    end
end

eifo.utils.lifo = lifo

eifo.utils.responseError = responseError


eifo.utils.observable = {
    _attach = attach,
    _detach = detach,
    _notify = notify
}

return eifo.utils