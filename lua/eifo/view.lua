---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tnguyen.
--- DateTime: 9/22/23 9:55 AM
---

local utils = eifo.utils
local lock = require "eifo.lock"
local ngx = ngx

local _view = setmetatable({}, {__index = {
    _update = function ()
        ngx.log(ngx.WARN, "_update() is not implemented")
    end
}})

function _view:new(paths, viewFile)
    local view = setmetatable({}, self)
    self.__index = self

    view.template = viewFile
    -- local _, startPos = string.find(modelFile, "/lua/view/") 
    local package = "view"
    for i = 1, #paths, 1 do
        package = package.."."..paths[i]
    end
    view._observerId = package
    local viewInfo = require(package)
    if not viewInfo or type(viewInfo) ~= "table" then
        return nil
    end
    local tableDef = viewInfo.tableDef 
                    or assert(viewInfo.tableName and eifo.db.table[viewInfo.tableName])
    view.table = tableDef:new({
        leftColumns = viewInfo.leftColumns,
        rightColumns = viewInfo.rightColumns,
        skippedTables = viewInfo.skippedTables,
        toJsonColumns = viewInfo.toJsonColumns,
    })
    view.name = paths[#paths]
    view.loadData = viewInfo.loadData
    view.layout = viewInfo.layout
    view.layoutUri = viewInfo.layoutUri
    view.key = viewInfo.key
    if view.key then
        paths[#paths] = nil
    end
    view.toJson = viewInfo.toJson
    if viewInfo.outputFile then
        local outPath = eifo.basePath.."/home"
        for i = 1, #paths, 1 do
            if paths[i] ~= "index" then
                outPath = outPath.."/"..paths[i]
                -- check if location exists:
                local ok, _, code = os.rename(outPath, outPath)
                if not ok and code ~= 13 then
                    -- if not, create the dir
                    os.execute("mkdir "..outPath)
                    os.execute("mkdir "..outPath.."/no_layout")
                end
            end
        end
        view.outPath = outPath
        view.table:_attach(view)
    end
    view.paths = paths

    return view
end

_view.getConn = function (...)
    local conn, err = eifo.db.conn.redis()
    if not conn then
        return nil, err
    end
    conn:connect()
    return conn
end
_view.getOutFile = function(self, key, noLayout)
    local sub = noLayout and "/no_layout/" or "/"
    if self.key then
        return self.outPath..sub..self.name..".html"
    end
    return self.outPath..sub..key..".html"
end

_view._update = function(self, records, oldVals, newVals) --TODO: 
    local record = records[1]
    local outFile = self:getOutFile(record.key)
    local lockObj = lock(outFile)
    if lockObj then
        os.remove(outFile) --> the updater should remove this lock
    end
    local outFile = self:getOutFile(record.key)
    local lockObj = lock(outFile)
    if lockObj then
        os.remove(outFile) --> the updater should remove this lock
    end

    outFile = self:getOutFile(record.key, true)
    lockObj = lock(outFile)
    if lockObj then
        os.remove(outFile)
    end
end

_view.process = function(self, params, noLayout)
    ngx.log(ngx.INFO, (self.name or "root")..": "..table.concat(params, ","))
    local numParams = (params and #params) or 0
    
    local conn = self:getConn()
    if not conn then
        utils.responseError(500, "Got some problems! We will fix it soon. Please come back later")
        return
    end
    conn:connect()
    local model, key, err = self:loadData(params, conn)
    conn:disconnect()
    if not model then
        ngx.log(ngx.INFO, err)
        utils.responseError(ngx.HTTP_NOT_FOUND, "Page not found ")
        return
    end

    local renderedText = self:render(model, noLayout)
    ngx.header.content_type = self.contentType
    ngx.send_headers()
    ngx.print(renderedText)
    ngx.eof()

    if self.outPath then
        local outPathFile = self:getOutFile(key, noLayout)
        local lock = require "eifo.lock"(outPathFile)
        if lock then -- write renderedText to a static file 
            local f = assert(io.open(outPathFile, "w"))
            f:write(renderedText)
            f:close()
            lock:unlock()
        end
    end
end
_view.loadData = function(self, params, conn)
    local tbl, key
    if self.key then
        params = {key = self.key}
    elseif #params == 1 then
        params = {key = params[1]}
    elseif not params or #params == 0 then
        return nil, nil, "No search params"
    end
    if self.table then
        tbl = self.table:new()
        tbl:init()
        key = self.table:generateKey(params)
        ngx.log(ngx.DEBUG, "Loading key "..key)
        local record, err = tbl:load({key = key}, conn)
        if not record then
            err = err or "No records found. Please check maxLevel setting"
            return nil, nil, err
        end
    end
    return tbl, key
end
_view.render = function(self, model, noLayout)

    model = model or {}

    --ngx.log(ngx.DEBUG, "\r\n\r\n Rendering: \r\n")
    if self.template then
        local template = require("resty.template")
        local fn = template.compile(self.template, "no-cache")
        local sHtml = fn({model = model, main = "{* main *}"}) --> main for layout pre-compile
        if noLayout or not (self.layoutUri or self.layout) then
            return sHtml
        end
        local fnLayout
        if self.layoutUri then
            ngx.req.read_body()
            --ngx.location.capture.options= 
            local res = ngx.location.capture(self.layoutUri, 
                {copy_all_vars = false,
                share_all_vars = false, 
                always_forward_body = false, 
                method = ngx.HTTP_GET, 
                args = {}, body = "", ctx = {}, vars = {}})
            local sLayout = res.body
            fnLayout = template.compile(sLayout, true)
        else
            fnLayout = template.compile(self.layout)
        end
        --ngx.log(ngx.DEBUG, utils.toJson(fnLayout))
        return fnLayout({main = sHtml, model = model})
    end
    if self.toJson then
        return self:toJson(model)
    end
    return model:toJson()
end


return _view