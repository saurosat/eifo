---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tnguyen.
--- DateTime: 9/22/23 9:55 AM
---
local utils = eifo.utils
local RequestContext = require("eifo.RequestContext")
local viewClass = require("eifo.view")
local lock = require "eifo.lock"
local ngx = ngx
local Route = {}

function Route:new(routeInfo)
    routeInfo = routeInfo or {}
    routeInfo.pos = routeInfo.pos or 0
    routeInfo.path = routeInfo.path or "/" --> must start and end with "/"
    if string.sub(routeInfo.path, 1, 1) ~= "/" then
        routeInfo.path = "/"..routeInfo.path
    end
    if string.sub(routeInfo.path, -1, -1) ~= "/" then
        routeInfo.path = routeInfo.path.."/"
    end
    return setmetatable(routeInfo, {__index = self})
end

function Route:getClass()
    local metatbl = getmetatable(self)
    return metatbl and metatbl.__index or nil
end

function Route:getRoute(uriStr, context)
    context = context or RequestContext:new({uri = uriStr})

    local startPos, _ , fileExt = string.find(uriStr, "%.(%a+)$")
    if startPos then
        uriStr = string.sub(uriStr, 1, startPos - 1)
    end
    local pathParams = eifo.utils.getPathParam(uriStr)
    if pathParams[1] == "api" then
        table.remove(pathParams, 1)
    end
    if pathParams[#pathParams] == "_EN_"  then
        ngx.ctx.lang = "en"
        pathParams[#pathParams] = nil
    elseif pathParams[#pathParams] == "_VI_" then
        ngx.ctx.lang = "vi"
        pathParams[#pathParams] = nil
    elseif pathParams[#pathParams] == "_CN_" then
        ngx.ctx.lang = "cn"
        pathParams[#pathParams] = nil
    else
        ngx.ctx.lang = ngx.ctx.lang or "en" --> default language
    end
    local pathPrefix = fileExt and eifo.pathPrefixes[fileExt]
    if pathPrefix and pathParams[1] ~= pathPrefix  then
        table.insert(pathParams, 1, pathPrefix)
    end

    local node = self
    for i = self.pos + 1, #pathParams, 1 do
        if not node[pathParams[i]] then
            break
        end
        node = node[pathParams[i]]
    end
    if node.pos == #pathParams and not node.view and node["index"] then --> index page
        node = node["index"]
    end
    local pos = node.pos + 1

    local noLayout
    if pathParams[pos] == "no_layout" then
        pos = pos + 1
        noLayout = "no_layout"
    end
    context.noLayout = noLayout

    local params = {table.unpack(pathParams, pos)}    
    if #params > 0 then
        context.params = params
        local view = node.view
        if view then
            context.key = view:getKey(context)
        end
    end

    return node, context
end

function Route:addView(paths, view, fileExt)
    local route = self
    local pathPrefix = fileExt and eifo.pathPrefixes[fileExt]
    if pathPrefix and paths[1] ~= pathPrefix then
        table.insert(paths, 1, pathPrefix)
    end
    ngx.log(ngx.DEBUG, utils.toJson(paths), pathPrefix or " no prefix")

    local numDirs = #paths - 1
    for i = 1, numDirs, 1 do
        route = route:addRoute(paths[i], {outputFile = view.outputFile})
    end
    route = route:addRoute(paths[#paths], view)
    if fileExt then
        route.fileExt = fileExt
    end
end

function Route:addRoute(subName, subView)
    subView = subView or {}
    local subPath = self.name and self.path..self.name.."/" or self.path

    local routeKey = subName
    if subView.outputFile and subView.requireKey then
        local dir = subPath.."/"..subName
        local dirExist, _, code = os.rename(dir, dir) --> check if location exists:
        if not dirExist and code ~= 13 then --> if not, create the dir
            os.execute("mkdir "..dir) --> make dir for any non-view route having child view routea
            if subView.name then --> real view, not emptyView
                os.execute("mkdir "..dir.."/no_layout")
                subPath = dir.."/"
                subName = nil
            end
        end
    end
    local route = self[routeKey]
    if route then
        assert(route.view == nil or route.view == subView, "There is another view routed to this path: "..(route.view and route.view.name or "nil"))
        route.path = subPath
        route.name = subName
    else
        route = Route:new({name = subName, path = subPath, pos = self.pos + 1, basePath = self.basePath})
        self[routeKey] = route
    end
    if subView then
        if subView.name then --> real view, not emptyView
            route.view = subView
            if subView.table and subView.outputFile then 
                route._observerId = subView.name
                subView.table:_attach(route)
            end
        elseif subView.filePath then
            route.filePath = subView.filePath
        end
    end
    return route
end
function Route:getFileExt()
    if not self.fileExt then
        if self.view and not self.view.templatePath then
            self.fileExt = "json"
        else --> if not self.view then self.filePath must exists:
            local filePath = self.filePath or (self.view and self.view.templatePath)
            local _, _ , fileExt = filePath and string.find(filePath, "%.view%.(%a+)$") or nil, nil, "html"
            self.fileExt = fileExt
        end
    end
    return self.fileExt
end
function Route:getContentType()
    if not self.contentType then
        self.contentType = eifo.contentTypes[self:getFileExt()]
    end
    return self.contentType
end
function Route:getFilePath(context)
    if self.filePath then
        return self.filePath
    end

    context = context or {}
    local params
    local view = self.view
    if view then
        if not view.outputFile then
            return nil
        end
        if view.requireKey then
            local key = view:getKey()
            if not key then
                return nil, "Not enough params to generate key for view '"..view.name.."', params: "..utils.toJson(params)
            end
            params = {key}
            context.key = key
        else
            params = {}
        end
    else
        params = context.params or {}
    end
    if self.name then
        table.insert(params, 1, self.name)
    end
    local num = #params
    if num == 0 then
        return nil
    end
    if context.noLayout == "no_layout" then
        params[num + 1] = params[num]
        params[num] = "no_layout"
    end
    local filePath = (self.basePath or "")..self.path..table.concat(params, "/").."."..self:getFileExt()
    context.filePath = filePath
    return filePath
end
function Route:loadFromFile(context)
    local filePath, err = self:getFilePath(context)
    if not filePath then
        return nil, err
    end
    local content, fileErr = utils.read_file(filePath)
    if not content then
        ngx.log(ngx.DEBUG, "Cannot read file "..filePath..": "..(fileErr or "Unknown reason"))
    end
    return content, fileErr
end
function Route:saveToFile(renderedText, context)
    if not self.view or not self.view.outputFile then
        return
    end
    local outPathFile = self:getFilePath(context)
    assert(outPathFile, self.view.name..": Cannot get output file. context = "..utils.toJson(context))
    local fLock = lock(outPathFile)
    if fLock then -- write renderedText to a static file 
        local f = assert(io.open(outPathFile, "w"))
        f:write(renderedText)
        f:close()
        fLock:unlock()
    end
end
function Route:_update(records, oldVals, newVals)
    local record = records[1]
    self:removeOutFile({key = record.key})
    self:removeOutFile({key = record.key, noLayout = "no_layout"})
end
function Route:removeOutFile(context)
    local outFile = self:getFilePath(context)
    if not outFile then
        return
    end
    local fLock = lock(outFile)
    if fLock then
        os.remove(outFile) --> the updater should remove this lock
        fLock:unlock()
    end
end

return Route