---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tnguyen.
--- DateTime: 9/22/23 9:55 AM
---

local utils = eifo.utils
local viewClass = require("eifo.view")
local lock = require "eifo.lock"
local ngx = ngx
local Route = {}

function Route:new(routeInfo)
    routeInfo = routeInfo or {}
    routeInfo.pos = routeInfo.pos or 0
    routeInfo.path = routeInfo.path or ""
    return setmetatable(routeInfo, {__index = self})
end

function Route:getClass()
    local metatbl = getmetatable(self)
    return metatbl and metatbl.__index or nil
end

function Route:render(params, noLayout)
    if not self.view then
        ngx.log(ngx.DEBUG, "Requesting route "..self.path..":"..(self.name or "NA").." has no view")
        return nil, ngx.HTTP_NOT_FOUND
    end
    return self.view:render(params, noLayout)
end

function Route:getRoute(uriStr)
    local startPos, _ , fileExt = string.find(uriStr, "%.(%a+)$")
    if startPos then
        uriStr = string.sub(uriStr, 1, startPos - 1)
    end
    local pathParams = eifo.utils.getPathParam(uriStr)
    if pathParams[1] == "api" then
        table.remove(pathParams, 1)
    end
    local pathPrefix = fileExt and eifo.pathPrefixes[fileExt]
    if pathPrefix and pathParams[1] ~= pathPrefix  then
        table.insert(pathParams, 1, pathPrefix)
    end

    local node = self
    for i = self.pos + 1, #pathParams, 1 do
        if not node[pathParams[i]] then
            break
        end
        node = node[pathParams[i]]
    end
    if node.pos == #pathParams and not node.view and node["index"] then --> index page
        node = node["index"]
    end
    local pos = node.pos + 1
    local noLayout = false
    if pathParams[pos] == "no_layout" then
        pos = pos + 1
        noLayout = true
    end
    local view = node.view
    local params = {table.unpack(pathParams, pos)}
    params = view and {view:getKey(params)} or params

    return node, params, noLayout
end

function Route:addView(paths, view, fileExt)
    local route = self
    local pathPrefix = fileExt and eifo.pathPrefixes[fileExt]
    if pathPrefix and paths[1] ~= pathPrefix then
        table.insert(paths, 1, pathPrefix)
    end
    ngx.log(ngx.DEBUG, utils.toJson(paths), pathPrefix or " no prefix")

    local numDirs = #paths - 1
    for i = 1, numDirs, 1 do
        route = route:addRoute(paths[i], {outputFile = view.outputFile})
    end
    route = route:addRoute(paths[#paths], view)
    if fileExt then
        route.fileExt = fileExt
    end
end

function Route:addRoute(subName, subView)
    subView = subView or {}
    local subPath = self.name and self.path.."/"..self.name or self.path

    local routeKey = subName
    if subView.outputFile and not subView.key then
        local dir = subPath.."/"..subName
        local dirExist, _, code = os.rename(dir, dir) --> check if location exists:
        if not dirExist and code ~= 13 then --> if not, create the dir
            os.execute("mkdir "..dir) --> make dir for any non-view route having child view routea
            if subView.table then --> real view, not emptyView
                os.execute("mkdir "..dir.."/no_layout")
                subPath = dir
                subName = nil
            end
        end
    end
    local route = self[routeKey]
    if route then
        assert(route.view == nil or route.view == subView, "There is another view routed to this path: "..(route.view and route.view.name or "nil"))
        route.path = subPath
        route.name = subName
    else
        route = Route:new({name = subName, path = subPath, pos = self.pos + 1})
        self[routeKey] = route
    end
    if subView then
        if subView.name then --> real view, not emptyView
            route.view = subView
            if subView.table and subView.outputFile then 
                route._observerId = subView.name
                subView.table:_attach(route)
            end
        elseif subView.filePath then
            route.filePath = subView.filePath
        end
    end
    return route
end
function Route:getFileExt()
    if not self.fileExt then
        self.fileExt = (not self.template and "json") or "html"
    end
    return self.fileExt
end
function Route:getContentType()
    if not self.contentType then
        self.contentType = eifo.contentTypes[self:getFileExt()]
    end
    return self.contentType
end
function Route:getFilePath(params, noLayout)
    if self.filePath then
        return self.filePath
    end
    params = params or {}
    local view = self.view
    if view then
        if not view.table or not view.outputFile then
            return nil, nil
        end
        if not view.key then
            local key = params.key or (#params == 1 and params[1]) or view.table:generateKey(params)
            assert(key, "Not enough params to generate key for view '"..view.name.."', params: "..table.concat(params, ", "))
            params = {key}
        else
            params = {}
        end
    end
    if self.name then
        table.insert(params, 1, self.name)
    end
    local num = #params
    if num == 0 then
        return nil, nil
    end
    if noLayout then
        params[num + 1] = params[num]
        params[num] = "no_layout"
    end
    return self.path.."/"..table.concat(params, "/").."."..self:getFileExt()
end
function Route:loadFromFile(params, noLayout)
    local filePath = self:getFilePath(params, noLayout)
    if not filePath then
        return nil
    end
    local content, fileErr = utils.read_file(filePath)
    if not content then
        ngx.log(ngx.DEBUG, "Cannot read file "..filePath..": "..(fileErr or "Unknown reason"))
    end
    return content, filePath
end
function Route:saveToFile(renderedText, params, noLayout, outPathFile)
    if not self.view or not self.view.outputFile then
        return
    end
    local key = params.key or params[1]
    outPathFile = outPathFile or self:getFilePath({key}, noLayout)
    assert(outPathFile, self.view.name..": Cannot get output file for key '"..key.."'")
    local fLock = lock(outPathFile)
    if fLock then -- write renderedText to a static file 
        local f = assert(io.open(outPathFile, "w"))
        f:write(renderedText)
        f:close()
        fLock:unlock()
    end
end
function Route:_update(records, oldVals, newVals)
    local record = records[1]
    local keyObj = {key = record.key}
    self:removeOutFile(keyObj)
    self:removeOutFile(keyObj, true)
end
function Route:removeOutFile(key, noLayout)
    local outFile = self:getFilePath({key = key}, noLayout)
    if not outFile then
        return
    end
    local fLock = lock(outFile)
    if fLock then
        os.remove(outFile) --> the updater should remove this lock
        fLock:unlock()
    end
end

return Route