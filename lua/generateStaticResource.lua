---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by tnguyen.
--- DateTime: 9/7/23 11:54 PM
---
if not prevIdx or not nextIdx then
    prevIdx = function(i, n) if i == 1 then return n else return i - 1 end end
    nextIdx = function(i, n) if i == n then return 1 else return i + 1 end end
end


local redisAgent = require "resty.redis"
local redis = redisAgent:new()
redis:set_timeouts(10000) -- 10 sec
local ok, errConn = redis:connect("127.0.0.1", 6379)
if not ok then
    responseError(ngx.HTTP_INTERNAL_SERVER_ERROR, "failed to connect to Redis: " + errConn)
    return
end
local catIds = redis:smembers("new:c")
local catFVs = redis:hgetall(catIds[1])
ngx.say("<!--"..": "..table.concat(catFVs,", ").."-->")
local cat = {}
for i = 1, #catFVs - 1, 2 do
    cat[catFVs[i]] = catFVs[i+1]
end
if(not catIds or #catIds == 0) then
    ngx.say("Query key new:c return empty results")
else
    ngx.say("<!--"..table.concat(catIds,", ").."-->")
end
local productIds = redis:smembers("new:p")
ngx.say("<!--"..table.concat(productIds,", ").."-->")
local products = {}
for i = 1, #productIds do
    local productFVs = redis:hgetall(productIds[i])
    ngx.say("<!--"..productIds[i]..": "..table.concat(productFVs,", ").."-->")
    local product = {}
    for j = 1, #productFVs - 1, 2 do
        product[productFVs[j]] = productFVs[j+1]
    end
    products[i] = product
end
-- Load promotions:
local promotions = {{imgLocation="/img/promo1.jpeg", description="Buy one get one free"}, {imgLocation="/img/promo2.jpeg", description="Sale 50% OFF for handsome boys"}, {imgLocation="/img/promo3.jpeg", description="Instant free ship to door"}}
--local promotionIds redis:smembers("new:promo")
--for i=1, #promotionIds do
--    local promoFVs = redis:hgetall(promotionIds[i]) -- return an array of strings
--    for j = 1, #promoFVs - 1, 2 do
--        promotions[promoFVs[j]] = promoFVs[j+1]
--    end
--end

-- Generate index.html:
local template = require "resty.template".new({location="/"})
local func = template.compile("index.template.html", "no-cache")
local html = func({category = cat, items = products, promotions = promotions})
ngx.say(html)
local basePath = ngx.var.basePath
local f = assert(io.open(basePath.."/templates/render_temp/index.html", "w"))
f:write(html)
f:close()
os.remove(basePath.."/home/index.html")
os.rename(basePath.."/templates/render_temp/index.html", basePath.."/home/index.html")



--[[
func = template.compile("promotions1.carousel.template.html", "no-cache") -- return a function
html = func({promotions = promotions}) -- call the returned func to create html string
ngx.say(html) -- write the html string to output stream (in this case is Response stream)
local basePath = ngx.var.basePath
local f = assert(io.open(basePath.."/templates/render_temp/promotions1.html", "w"))
f:write(html)
f:close()
os.remove(basePath.."/home/promotions1.html")
os.rename(basePath.."/templates/render_temp/promotions1.html", basePath.."/home/promotions1.html")
]]

-- TODO: generate other pages
-- Everything is up-to-date:
--redis:del("new:c")
--redis:del("set:c")
--redis:del("del:c")
--redis:del("new:p")
--redis:del("set:p")
--redis:del("del:p")
redis:set_keepalive(10000, 50) -- maintain 50 connections in connection pool, with 10s timeout

--local view = template.process_file("productsByCategory.grid.template.html", {category = cat, products = products}, "no-cache")

--local html = view:process()
--local template_string = ngx.location.capture("/e-commerce-home-page/index.template.html")
--local html = template.process(template_string.body, {category = cat, products = products})
